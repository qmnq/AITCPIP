#include <stdio.h>
/*
10.1.1文件的定义：
一、文件: 1.磁盘文件：一组相关数据的有序集合，通常存储在外部介质（如：磁盘）上，使用时才调入内存
         2.设备文件：在操作系统中，把每一个与主机相连的输入输出设备看作是一个文件，把他们的输入输出等同于对磁盘文件的读和写。
            例如： 键盘：标准输入文件       屏幕：标准输出文件

        Linux操作系统中，每一个外部设备都在 /dev 目录下对应着一个设备文件，咱们在程序中想要操作设备，就必须对与其对应的 /dev 下的设备文件进行操作。

        3.标准IO库函数对磁盘文件的读取特点：

            内存          输出\输入             磁盘

          程序    ――> 文件缓冲区（系统\程序）――>   文件
         数据区  <――   文件缓冲区（系统\程序）<――

        文件缓冲区 是 库函数 申请的一段内存，由 库函数 对其进行操作，程序员没有必要知道存放在哪里， 只需要知道对文件操作的时候的一些缓冲特点即可。
        举例:放苹果到办公室的例子
二、缓冲区的分类：
        1.行缓冲：
                （相对于终端而言的：不刷新缓冲区，是无法直接去执行读写操作的）
                标准IO库函数，往标准输出(屏幕)输出东西的时候是行缓冲的

                行缓冲的刷新条件：
                    1.使用\n
                    2.程序正常结束
                    3.使用fflush函数刷新缓冲区
                    4.当缓冲区满的时候自动刷新,默认行缓冲的大小为1024个字节

        2.全缓冲：
                （主要是对文件进行操作的时候，尤其是普通文件进行读写操作的时候，主要是在全缓冲里面进行的）
                标准io库函数 ，往普通文件读写数据的，是全缓冲的
                碰到换行符也不刷新缓冲区，即缓冲区满了，才刷新缓冲区

                刷新缓冲区的情况:
                1.缓冲区满了，刷新缓冲区
                2.人为刷新缓冲区 fflush(文件指针)
                3.程序正常结束 会刷新缓冲区
        3.无缓冲：
                (一些库函数在调用的时候是不需要缓冲区的)
                在读写文件的时候通过系统调用io(read write),对文件进行读写数据
                这个时候是无缓冲的，即写数据会立马进入文件，读数据会立马进入内
*/


/*
10.1.2磁盘文件的分类：
    一个文件通常是磁盘上一段命名的存储区
    计算机的存储在物理上是二进制的,
    所以物理上所有的磁盘文件本质上都是一样的：以 字节 为单位 进行顺序存储

    从用户或者操作系统使用的角度(逻辑上)把文件分为:
        文本文件：基于 字符 编码的文件
        二进制文件：基于 值 编码的文件

            文本文件：基于字符编码，常见编码有 ASCII、UNICODE 等
                    一般可以使用文本编辑器直接打开
            例如:数5678的以ASCII存储形式为:
            ASCI 码:00110101 00110110 00110111 00111000
            歌词文件(lrc):文本文件

            二进制码文件:
            基于值编码,自己根据具体应用,指定某个值是什么意思
            把内存中的数据按其在内存中的存储形式原样输出到磁盘上
            一般需要自己判断或使用特定软件分析数据格式
            例如:数 5678 的存储形式为:
                二进制码：00010110 00101110

    音频文件(mp3):二进制文件

    图片文件(bmp)文件，一个像素点 由两个字节 来描述 RGB：*****######&&&&&
    *代表红色的值
    #代表绿色的值
    &代表蓝色的值
    二进制文件以位来表示一个意思


    文本文件、二进制文件对比:
    译码:
        文本文件编码基于字符定长，译码容易些:
        二进制文件编码是变长的，译码难一些(不同的二进制文件格式，有不同的译码方式)
    空间利用率:
        二进制文件用一个比特来代表一个意思(位操作);
        而文本文件任何一个意思至少是一个字符。

        二进制文件，空间利用率高。
        (文本文件以 字节 为 单位，一个字节就是8 比特位，二进制是用 比特位 为 单位)

    可读性:
        文本文件 用通用的 记事本工具 就几乎 可以浏览所有文本文件
        二进制文件 需要一个具体的  文件解码器 ，比如读 BMP文件，必须用读图软件。

总结：
    文件 在 硬盘 上存储时，物理上 都是用 二进制 来存储的。
    咱们的标准io库函数，对文件操作的时候，不管文件的编码格式(字符编码、或二进制)，
    而是按字节对文件进行读写，所以咱们管文件又叫流式文件，即把文件看成一个字节流。
*/


/*
10.2文件指针：就是用于标识一个文件的，所有对文件的操作都是用对文件指针进行操作的
    在程序中用于表示一个文件。

    定义文件指针的一般形式：
        FILE* 指针变量标识符；
            FILE 为大写，需要头文件<stdio.h>
            FILE是系统使用 typedef定义出来的有关文件信息的一种结构体类型，结构中含有文件名，文件状态和文件位置等信息。

    一般情况下, 我们操作文件前必须定义一个文件指针标识 我们将要操作的文件
    实际编程中使用库函数操作文件，无需关心FILE结构体的细节 ，只需要将文件指针传给 io库函数，
    库函数 再 通过FE结构体里的信息对文件进行操作。

    FILE 在stdio.h文件中的文件类型声明：(本质上文件指针就是一个结构体指针，结构体中包含当前文件的很多信息，但编程时，不需关心结构体的成员，只需使用文件指针即可）
    typedef struet
    {
        short level;    //缓冲区“满”或“空”的程度
        unsigned flags; //文件状态标志
        char fd;        //文件描述符
        unsigned charhold;   //如无缓冲区不读取字符
        short bsize;        //缓冲区的大小
        unsigned char *buffer;//数据缓冲区的位置
        unsigned ar*cup;    //指针，当前的指向
        unsigned istemp;    //临时文件，指示器
        shorttoken; //用于有效性检查
    }FILE;
    在缓冲文件系统中，每个被使用的文件都要在内存中开辟一块FILE类型的区域，存放与操作文件相关的信息。

对文件操作的步骤:
1、对文件进行读写等操作之前要打开文件得到文件指针
2、可以通过文件指针对文件进行读写等操作
3、读写等操作完毕后，要关闭文件，关闭文件后，就不能再通过此文件指针操作文件了

c语言中有三个特殊的文件指针无需定义，在程序中可以直接使用
    stdin :标准输入 默认为当前终端(键盘)
        我们使用的scanf、getchar函数默认从此终端获得数据
    stdout:标准输出 默认为当前终端(屏幕)
        我们使用的printf、puts函数默认输出信息到此终端
    stderr:标准错误输出设备文件 默认为当前终端(屏幕 )
        当我们程序出错使用:perror函数时信息打印在此终端
*/

/*
打开文件：
    FILE *fopen(const char*path,const char* mode);

函数说明：
    打开一个已经存在的文件，并返回文件的文件指针。
    或创建一个文件，并打开，然后返回文件指针。

函数参数：
    参数一：1.打开的文件的路径
                1.绝对路径
                2.相对路径
    参数二：文件的打开方式：（只读r，只写w，可读可写a ）

    r / rb   以只读方式打开一个文本文件（不创建文件）
    w / wb   以写方式打开文件（使文件长度截断为0字节，创建一个文件）
    a / ab   以添加方式打开文件，即在末尾添加内容，当文件不存在时，创建文件用于写
    r+ / rb+ 以可读、可写的方式打开文件（不创建新文件）
    w+ / wb+ 以可读、可写的方式打开文件（使文件长度为0字节，创建一个文件）
    a+ / ab+ 以添加方式打开文件，打开文件并在末尾更改文件（若文件不存在，则创建文件）

返回值：
    成功：打开的文件对应的文件指针
    失败：返回NULL

注意：调用fopen函数的时候，一定要先判断一下，打开是否成功。



关闭文件：头文件：<stdio.h>
    FILE *fclose(FILE* fp);
函数说明：
    关闭fp所代表的文件
    注意：一个文件只能关闭一次，不能多次关闭。关闭之后就不能再对文件指针进行读写等操作了。
返回值：
    成功返回：0
    失败返回：非0
    注意：可以通过返回值来判断关闭文件是否成功。
*/


/*10.5
一次读写一个字符：

函数定义:（读）
    int fgetc(FILE *stream);
函数说明：
    fgetc从stream所标识的文件读取一个字节，将字节值返回。
返回值：
    以t的方式:  读到文件结尾返回 EOF
    以b的方式:  读到文件结尾，使用 fo后面会讲)判断结尾

函数的定义:（写）
    int fputc(int c, FILE *stream)
 函数的说明:
    fputc 将c的值写到 stream 所代表的文件中。
返回值:
    如果输出成功，则返回输出的字节值;
    如果输出失败，则返回一个EOF.
    (EOF是在 stdio.h文件中定义的符号常量，值为-1)

注意:打开文件的时候，默认读写位置在文件的开始，如果以a的方式打开读写位置在文件的末尾
咱们向文件中读取字节或写入字节的时候，读写位置会往文件的末尾方向偏移，读写多少个学节，读写位置就往
文件的末尾方向偏移多少个字节.
*/

/*
一次读写一个字符串：
函数的定义:
    char *fgets(char *s,int size, FILE *stream);
函数的说明:
    从 stream 所指的文件中读取字符，在读取的时候 碰到换行符 或者是 碰到文件的末尾停止读取
    或者是读取了 size-1 个字节停止读取，在读取的内容后面会加一个\0,作为字符串的结尾
返回值:
    成功返回目的数组的首地址，即s
    失败返回 NULL

函数的定义:
    int fputs(const char *s, FIE *stream);
函数的说明:
    将s指向的字符串，写到stream 所代表的文件中
返回值：
    成功返回写入的字节数
    失败返回-1
*/


/*
读文件：
函数的定义:
    size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
函数的说明:
    fead,函数从 stream 所标示的文件中读取数据, 一块是 size 个字节，共nmemb块，存放到 ptr指向的内存里
返回值:
    实际读到的块数。

    例1:
    int num;
    num=fread(str,100,3,fp);
    从fp,所代表的文件中读取内容存放到 str 指向的内存中，读取的字节数为：每块 100个字节，3 块。
    返回值 num，
    如果读到了 300 个字节返回值 mum为3
    如果读到了大于等于200个字节小于300个字节，返回值为2
    读到的字节数大于等于100个字节小于200个字节，返回1
    不到100个字节返回 0

*/

/*
写文件：
函数的定义:
    size_t fwrite(void *ptr, size_t size, size_t nmemb, FILE *stream);
函数的说明:
    fwrite,函数将 ptr,指向的内存里的数据，向 stream 所标示的文件中写入数据
    一块是 size 个字节，共 nmemb 块。
返回值:
    实际写入的块数

注意：读文件和写文件都是针对同一个 文件偏移量，故写完文件后重新读取时，需使用 rewind 函数，刷新偏移量，从头开始读。
*/

/*
10.9格式化读写文件函数：
函数调用:
    fprint(文件指针，格式字符串，输出表列)
    fscanf(文件指针，格式字符串，输入表列)

函数功能:
    从磁盘文件中读入或输出字符

fprintf 和 printf函数类似:
    printf是将数据输出到屏幕上(标准输出)
    fprintf函数是将数据输出到文件指针所指定的文件中

fscanf 和 scanf 函数类似:
    scanf是从键盘(标准输入)获取输入，
    fscanf是从文件指针所标示的文件中获取输入。

*/


/*
随机读写：偏移量定位
    前面介绍的对文件的读写方式都是顺序读写，即读写文件只能从头开始，顺序读写各个数据:
但在实际问题中常要求只读写文件中某一指定的部分，例如:读取文件第 200--300个字节
    为了解决这个问题可以移动文件内部的位置指针到需要读写的位置，再进行读写，这种读写称为随机读写
实现随机读写的关键是要按要求移动位置指针，这称为文件的定位.

完成文件定位的函数有:
    rewind、fseek函数

1.rewind复位读写位置
    rewind函数：
        void rewind(文件指针);
    函数功能：
        把文件内部的位置指针移到文件首
    调用形式：
        rewind(文件指针);
2.ftell测文件读写位置距文件开始有多少个字节
    定义函数：
        long ftell（文件指针）;
    函数功能：
        取得文件流目前的读写位置
    返回值：
        返回当前读写位置（距离文件起始的字节数），出错时返回-1.
3.fseek 定位位置指针（读写位置）
    fseek函数（一般用于二进制文件，即打开文件的方式需要带b）
        定义函数：
            int fseek(FILE *stream,long offset, int whence);
            //int fseek(文件类型指针，位移量，起始点)；
        函数功能：
            移动文件流的读写位置
        参数：
            whence起始位置
                文件开头        SEEK_SET    0
                文件当前位置     SEEK_CUR    1
                文件末尾        SEEK_END    2
        位移量：
            以起始点位基点，向前、后移动的字节数，正数往文件末尾方向偏移，
                                             负数往文件开头方向偏移。
*/
int main()
{
    //由于printf函数是一个标准io，所以只有刷新缓冲区才可以将数据输出到终端
    //printf("hello world");

    //刷新缓冲区方法1:使用\n
    //printf("hello world\n");

    //刷新缓冲区方法2:程序正常结束
    //printf("hello world");
    //return 0;

    //刷新缓冲区内法3:使用fflush函数刷新缓冲区
    //printf("hello world");
    //fflush:刷新函数。可以刷新指定的缓冲区,函数功能就是刷新缓冲区
    //stdout:标准输出，就是对终端进行写操作
    //fflush(stdout);

    //刷新缓冲区方法4:当缓冲区满的时候自动刷新
    //默认行缓冲的大小为1024个字节
    int i;
    for(i=1;i<300;i++)
    {
        printf("%03d",i);//宽度为3,故输出四个字符
    }

    while(1)
    {
        ;
    }

    return 0;
}
