//常用内容及指令：
/*
// 查询ubuntu的mac地址
//        使用命令：ifconfig


//* 如何查询windows的硬件地址：
//      我的电脑——》控制面板——》网络和internet——》网络和共享中心——》更改适配器设置比——》网络——》双击打开后点详细信息——》物理地址（windows的MAC地址）。


//查询 IP 地址的命令：
//                    在ubuntu 中：
//                        使用：ifconfig。 lo 里面的地址
//                    在windows中：
//                        使用：ipconfig。

//如何判断主机是否可以连通通信：
//                    通过 ping 命令：
//                        ping ip地址   判断当前地址是否能够ping通。

//回环IP地址:只能主机自己使用
//                    通常127.0.0.1 称为回环地址。
//                通过 ifconfig 命令查询到的 lo里面的地址

//* 1.4.2 链路层封包格式:
//          两种格式：IEEE 和 以太网格式。大多使用以太网格式。
//                  目的地址：目的MAC地址。
//                  源地址  ：源（自己的）MAC 地址(MAC地址是 6个字节；IP地址是 4个字节)，
//                  类型    ：决定了后面跟的是什么协议。 （2个字节 4位16进制数）
//                             如果是 0x0800 就是 IP协议
//                             如果是 0x0805 就是ARP请求/应答
//                             如果是 0x0835 就是RARP请求/应答
//
//
//  IEEE802.2/802.3 封装
//                          | 目的地址 | 源地址 | 长度 | DSAPAA | SSAPAA | Cntl 03 | Org code 00 | 类型 |      数据      | CRC |
//                               6        6       2      1        1         1           3         2     38  ~ 1492       4

//          以太网格式        | 目的地址 | 源地址 | 类型 |                          数据                                   | CRC |
//                               6        6       2                         46  ~ 1500                                   4


//                                                                      0x0800| IP数据包
//                                                          类型 ： {    0x0806| ARP请求/应答
//                                                                      0x0835|RARP请求/应答


//1.4.3 网络层、传输层封包格式:
//                当以太网封装 的类型位0x0800,则表示IP数据包，对应网络层。

//                IP数据包的头部占20个字节，每一行都是4个字节

//        IP数据包：
//               ------------------------------------------
//               | 版本 | 首部长度 | 服务类型 |      总长度   |        --4字节   总长度：首部长度（原本头的长度）+数据部分长度
//               ------------------------------------------
//               |      标识                |标志| 分段偏移量|        --4字节
//               ------------------------------------------                             1:ICMP
//               |      生存期    |    协议  |   包头校验和  |                  协议分为 {  2:IGMP
//               ------------------------------------------                             6:TCP
//               |                源IP地址                 |                            17:UDP
//               ------------------------------------------
//               |                目的IP地址               |
//               ------------------------------------------
//               |                IP选项（可选）            |
//               ------------------------------------------
//               |                                        |
//               |                数据                    |
//               |                                        |
//                -----------------------------------------

//                IP的数据部分：
//                        UDP数据包：
//                                ----------------------------------------
//                                |      源端口      |       目的端口      |
//                                ----------------------------------------
//                                |       长度       |      UDP校验和     |
//                                ----------------------------------------
//                                |                                      |
//                                |               数据                    |
//                                |                                      |
//                                ----------------------------------------

//                        TCP数据包：
//                                ---------------------------------------
//                                |     源端口       |       目的端口     |
//                                ---------------------------------------
//                                |               序号                   |
//                                ---------------------------------------
//                                |               确认号                 |
//                                ---------------------------------------
//                                | 首部长度 | 保留 | 代码位 |     窗口    |
//                                ---------------------------------------
//                                |          校验和        |   紧急指针   |
//                                ---------------------------------------
//                                |       选项（如果有的话）        | 填充 |
//                                ---------------------------------------
//                                |                                     |
//                                |               数据                   |
//                                |                                     |
//                                ---------------------------------------



//        2.2.3 UDP编程C/S架构（客户端-服务器模型）

//                                                    UDP服务器:
//                                                    socket()
//                                                        |
//                                                      bind()
//                                                        |
//                                                    recvfrom() <————
//                                                        |
//           UDP客户端:                                    |           |
//            socket()                             一直阻塞到收到客户
//                |                                       数据
//                |                                       |           |
//       ————> sendto()        —— 数据请求——>              |           |
//     |          |                                       |
//     |          |                                    处理请求
//     |          |                                       |           |
//     <————  recvfrom()      <———数据应答———          sendto()    ————>
//                |
//              close()





*/


// 第一章：计算机网络概述
//（网络编程实质上就是另一种 进程间通信方式：套接字通信，套接字通信由于能实现不同主机之间进行沟通，所以更加复杂）
/*
    1.计算机网络概述
        1.1 计算机网络发展简史
            1.1.1 最早的广域网：
                在通信双方或多方之间，通过电路交换建立电路连接的网络。
                （早期的广域网 依靠与纯电路连接）

            1.1.2 电路交换网特点
                1、建立链接->使用链接->程放链接
                2、物理通路被通信双方独占
                计算机数据是实发式出现在数据链路上的,而电路交换网的建立链接、使用链接、释放链接的三个过程使得传输效率太低，故电路交换不适合传输计算机数据。

            1.1.3 计算机网络的要求：
                1957年10月4日,苏联发射了世界上第一颗人造地球卫星--Sputnik
                    针对 Sputnik 所带来的威胁,美国国会于1958年1月7日拔款成立 ARPA(theAdvanced ResearchProjects Agency美国高级研究计划署)
                对计算机网络的要求
                    1、不是为了打电话
                    2、结构简单，可靠的传输数据
                    3、能够连接不同种类的计算机
                    4、所有网络节点同等重要
                    5、必须有冗余的路由

                最早的计算机网络：是由美国创造的ARPA，但是最早的ARPA无法连接不同类型的计算机和不同类型的操作系统。

            1.1.4 分组交换:计算机网络中数据采用分组交换的方式
                通过 标有地址的分组 进行 路由选择传送数据 ，使 通信通道 仅在 传送期间被占用的 一种交换方式
                分组的组成:
                每个分组都由首部和数据段组成;
                    见图。

            1.1.5 交换方式：
                交换方式————储存转发
                节点收到分组，先暂时存储下来，再检查其首部，按照首部中的目的地址，找到合适的节点转发出去。
                    见图

                    分析：节点收到数据之后会存储，当找到合适的结点之后就会把数据发出去，发出信息后的节点便可以存储其它信息，不再像物理电路交换网一样一直占用。
                特点:
                    1、以分组作为传输单位
                    2、独立的选择转发路由   （已经发送过数据的路由会空闲下来去存储发送其它数据，数据的整个传输过程中不会被一直占用。）
                    3、逐段占用，动态分配传输带宽。

            1.1.6 因特网的发展史： （计算机网络的世界语--TCP/IP协议）
                从单个ARPANET向因特网发展的过程。
                1983年TCP/IP协议成为了APRANET的标准协议。

                (直到现在，只要是能够通信的机器，能够上网的机器，一定用的就是TCP/IP协议族--很多协议，不是只有这两个）

                1.1.6.1 三级结构的因特网。
                    （NSFNT国家科学基金网）
                     围绕六台大型计算机中心建设起来的计算机网络

                     （国家）主干网、 地区网、 校园网、 家庭网、 企业网、 局域网。

                     见图：
                                        国家主干网

                    地区网                 地区网                 地区网

                校园网  家庭网         企业网  局域网           家庭网  校园网


                1.1.6.2 多级结构因特网
                    NSFNET逐步被商用因特网主干网替代。
                    见图。

        1.2 TCP/IP协议简介
            为了使各种不同的计算机之间可以互联,ARPANet指定了一套计算机通信协议，即 TCP/P 协议(族)

            应用领域:
                为了减少协议设计的复杂性，大多数网络模型均采用分层的方式来组织
                每一层利用下一层提供的服务来为上一层提供服务
                本层服务的实现细节对上层屏蔽

            1.2.1 分层结构：
                为了实现不同类型的计算机和不同类型的操作系统之间进行通信，引入了分层的概念。

                最早的分层体系结构是OSI开放系统互联模型，是由国际化标准组织(ISO)指定的，由于OSI过于复
                杂，所以到现在为止也没有适用，而使用的是TCP/IP协议族。

            对比：OSI一个分为7层，TCP/IP协议族一共四层，虽然TCP/IP协议层次少，但是却干了OSI 7层所有的任务。

               OSI/RM(理论上的标准)              TCP/IP(事实上的标准)
                ---------------------------------------------------------
                    应用层
                --------------------
                    表示层                             应用层
                --------------------
                    会话层
                ---------------------------------------------------------
                    传输层                             传输层
                ---------------------------------------------------------
                    网络层                             网络层
                ---------------------------------------------------------
                    数据链路层
                --------------------                  链路层
                    物理层
                ---------------------------------------------------------


                （由于是TCP/IP协议族，所以每一层都会有自己对应的协议，虽然不会所有都用到）

                应用层:应用程序间沟通的层
                    例如:FTP、Telnet、HTTP等
                传输层:提供进程间的数据传送服务
                    负责传送数据，提供应用程序端到端的逻辑通信
                    例如:TCP、UDP
                网络层:提供基本的数据封包传送功能
                    最大可能的让每个数据包都能够到达目的主机
                    例如:IP、ICMP等
                链路层：负责数据帧的发送和接收

                每层完成自己的任务，最终通过不同层次的处理完成数据的收发

                我方：从上往下先传数据：应用层把数据先传输给传输层，传输层再把数据交给网络层，网络层再把数据交给链路层，
                因此，到达链路层之后，就不只数据部分，还含有其他东西。把整体数据交给链路层之后，再传给对方。
                对方接收到数据后，又从下往上传：先对比链路层（设备到设备），再对比网络层（主机对主机），再对比传输层（进程到进程），最终再把数据交给应用层。


            1.2.2 IP协议简介：又称网际协议，主要就是告知通信的对象是谁。

                特指为实现在一个相互连接的网络系统上 从源地址 到 目的地传输数据包(互联网数据包) 所提供必要功能的协议
                特点:
                    不可靠:它不能保证IP数据包能成功地到达它的目的地，仅提供尽力而为的传输服务
                    无连接:IP 并不维护任何关于后续数据包的状态信息。每个数据包的处理是相互独立的。IP 数据包可以不按发送顺序接收

                IP 数据包中 含有 发送它主机的IP 地址(源地址) 和 接收它主机的 IP 地址(目的地址)


            1.2.3 TCP 协议简介(TCP是传输层协议，负责传输)（传输控制协议：transport control）
                TCP 是一种面向连接的,可靠的传输层通信协议
                功能:
                    提供不同主机上的进程间通信
                特点
                    1、建立链接->使用链接->释放链接(虚电路)
                    2、TCP 数据包中包含序号和确认序号
                    3、对包进行排序并检错，而损坏的包可以被重传
                服务对象
                    需要高度可靠性且面向连接的服务
                    如 HTTP、FTP、SMTP 等

            1.2.4 UDP 协议简介：主要应用于语音、视频的通信
                （用户数据报协议）
            UDP是一种面向无连接的传输层通信协议
            功能:
                提供不同主机上的进程间通信
            特点：
                1、发送数据之前不需要建立链接
                2、不对数据包的顺序进行检查
                3、没有错误检测和重传机制
            服务对象：
                主要用于“查询一应答”的服务
                如:NFS、NTP、DNS等。

        1.3 MAC地址、IP 地址、Netmask、端口
            1.3.1 网卡
                又称为网络适配器 或 网络接口卡NIC，但是现在更多的人愿意使用更为简单的名称“网卡
                通过网卡能够使不同的计算机之间连接，从而完成数据通信等功能。
                （不同主机之间能够实现通信，能够上网都是因为有网卡的存在）

            1.3.2 mac地址
                每一个网卡在出厂的时候，会被分配一个编号，称之为MAC地址。

                MAC地址，用于标识网络设备，类似于身份证号，且理论上全球唯一
                组成：
                    以太网内的MAC地址是一个48bit的值，通常人为识别时是通过16进制数来识别的，以两个16进制数为一组，一共分为6组（位相当于占6个字节（1个字节8个比特位），而1位16进制数，相当于占了0.5个字节，所以一共分为6组），每组通过“：”分隔开。
                    前3组称为 厂商ID；后3组称为设备ID。(我们人为识别的是需要加“：”的一个字符串；如果是电脑识别，则是不加“：”的一个48bit的值)

          * 如何查询ubuntu的mac地址？
                使用命令：ifconfig

            例：
                    qinmei@qinmei-virtual-machine:~$ ifconfig
                    ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
                            inet 192.168.177.128  netmask 255.255.255.0  broadcast 192.168.177.255
                            inet6 fe80::2421:55cc:4885:fa0c  prefixlen 64  scopeid 0x20<link>

                            ether 00:0c:29:6d:54:32  txqueuelen 1000  (以太网)

                            RX packets 61532  bytes 89064950 (89.0 MB)
                            RX errors 0  dropped 0  overruns 0  frame 0
                            TX packets 6183  bytes 471906 (471.9 KB)
                            TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

                    lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
                            inet 127.0.0.1  netmask 255.0.0.0
                            inet6 ::1  prefixlen 128  scopeid 0x10<host>
                            loop  txqueuelen 1000  (本地环回)
                            RX packets 362  bytes 36341 (36.3 KB)
                            RX errors 0  dropped 0  overruns 0  frame 0
                            TX packets 362  bytes 36341 (36.3 KB)
                            TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0


            我们想要的就是ens33(虚拟网卡),硬件地址就是里面，两两一组，一共六组的编码，如：00:0c:29:6d:54:32.

          * 如何查询windows的硬件地址：
                我的电脑——》控制面板——》网络和internet——》网络和共享中心——》更改适配器设置比——》网络——》双击打开后点详细信息——》物理地址（windows的MAC地址）。
                例：
                    连接特定的 DNS 后缀:
                    描述: Intel(R) Wi-Fi 6 AX201 160MHz
                  * 物理地址: ‎6C-94-66-A4-84-40
                    已启用 DHCP: 是
                    IPv4 地址: 192.168.1.5
                    IPv4 子网掩码: 255.255.255.0
                    获得租约的时间: 2025年1月9日 10:08:17
                    租约过期的时间: 2025年1月10日 10:08:15
                    IPv4 默认网关: 192.168.1.1
                    IPv4 DHCP 服务器: 192.168.1.1
                    IPv4 DNS 服务器: 192.168.1.1
                    IPv4 WINS 服务器:
                    已启用 NetBIOS over Tcpip: 是
                    IPv6 地址: 240e:398:34c3:ab10:af40:6fb:4057:cb54
                    临时 IPv6 地址: 240e:398:34c3:ab10:ed88:a168:9e34:49b
                    连接-本地 IPv6 地址: fe80::7719:15ac:a084:67ab%11
                    IPv6 默认网关: fe80::1%11
                    IPv6 DNS 服务器: fe80::1%11

            1.3.3 IP地址
                IP地址是一种internet上的主机编址方式，也称为网际协议地址。
                IP地址是任意一台主机在网络中的唯一标识

                1.3.3.0 IP地址的分类
                    一般分为两类：
                        ipv4：占32位，4个字节。
                        ipv6：占128位，16个字节

                1.3.3.1 IPV4地址的组成 （ip地址组成）
                    ipv4 一般使用点分十进制字符串来标识，如：192.168.3.103
                    使用 32 bit,由 ( 网络ID ，主机ID) 两部分组成
                    子网 ID:IP 地址中由子网掩码中1覆盖的连续位
                    主机 ID:IP 地址中由子网掩码中0覆盖的连续位
        （ip与子网掩码二进制相与可以的得到网段， 固定网络位不变，主机位改变，此时的ip都处在同一个子网中）

                子网ID和主机ID为什么有这样一个区分？因为 通过主机ID的范围就可以确定当前的网段可以下分多少个主机，也就意味着可以分配多少个主机

                例：
                    10101100.00010100.11011111.01001011
                       172  .   20   .   223  .    75           IP地址
                       255  .   255  .   255  .     0           IP地址所对应的 子网掩码
                    ------------------------------------
                       127  .   20   .   233  .    75
                     <——       子网ID    ——>    <—主机ID->

                     （前三个255就是1，所以前三个字节就是子网ID，即：网络ID，只有最后一个是主机ID,由于最后一个占8位，所以最多可以分配256台主机）

                1.3.3.2 ip地址特点
                    子网ID不同的网络不能直接通信，如果要通信则需要路由器转发。（网络不同的网络是没有办法直接通信的，如果要通信，需要经路由器转发）
                    主机ID全为0的IP 地址 表示 网段地址
                    主机ID全为1的IP 地址 表示 该网段的广播地址

                    例：
                        192.168.3.10 和192.168.3.111可直接通信。
                        如果192.168.3.x 网段而言，192.168.3.0 表示网段，192.168.3.255表示广播地址,这两个地址是不能给主机分配的。其余的地址（1~254）都可以用来给主机分配。

                1.3.3.3 ip(ipv4)地址分类如下： (依据前8位(10101100)来进行区分)
                    A类地址:默认 8bit 子网ID,第一位为0      （前8位范围：0000 0000 ~ 0111 1111   网段范围：  0.x.x.x ~ 127.x.x.x）
                    B类地址:默认 16bit 子网ID,前两位为 10   （前8位范围: 1000 0000 ~ 1011 1111   网段范围：128.x.x.x ~ 191.x.x.x）
                    C类地址:默认24bit 子网ID,前三位为 110   （前8位范围: 1100 0000 ~ 1101 1111   网段范围：192.x.x.x ~ 223.x.x.x）
                    D类地址:前四位为 1110,多播（组播）地址   （前8位范围: 1110 0000 ~ 1110 1111   网段范围：224.x.x.x ~ 239.x.x.x）
                    E类地址:前五位为 11110,保留为今后使用    （前8位范围: 1111 0000 ~ 1111 1111   网段范围：240.x.x.x ~ 255.x.x.x）

                    A,B,C三类地址是最常用的.

                    公有IP（可直接连接Internet）
                        经由InterNIC所统一规划的IP
                    私有IP（不可直接连接Internrt）
                        主要用于局域网络内的主机联机规划

                    类型                  私有IP地址范围
                    A类      10.0.0.1    ~   10.225.255.254
                    B类     172.16.0.1   ~  172.31.255.254
                    C类     192.168.0.1  ~  192.168.255.254

                1.3.3.4 回环IP地址:只能主机自己使用
                    通常127.0.0.1 称为回环地址。
                通过 ifconfig 命令查询到的 lo里面的地址

                    功能：
                        主要是测试本机的网络配置，能ping通127.0.0.1，说明本机的网卡和IP协议安装都没有问题。
                    注意:
                        127.0.0.0 ~ 127.255.255.254 中的任何地址都将回环到本地主机中，不属于任何一个有类别地质类，他代表设备的本地虚拟接口。


                1.3.3.5 查询 IP 地址的命令：
                    在ubuntu 中：
                        使用：ifconfig。 lo 里面的地址
                    在windows中：
                        使用：ipconfig。
                        例：
                            无线局域网适配器 本地连接* 4:

                               连接特定的 DNS 后缀 . . . . . . . :
                               本地链接 IPv6 地址. . . . . . . . : fe80::253d:8f6d:2e75:5e8f%17
                               IPv4 地址 . . . . . . . . . . . . : 192.168.137.1
                               子网掩码  . . . . . . . . . . . . : 255.255.255.0
                               默认网关. . . . . . . . . . . . . :

                1.3.3.6 如何判断主机是否可以连通通信：
                    通过 ping 命令：
                        ping ip地址   判断当前地址是否能够ping通。

                        例 1：
                            我们由 1.3.3.5 已知：IPv4 地址 . . . . . . . . . . . . : 192.168.137.1
                            故： ping一下windows主机，看看能不能连通。
                                qinmei@qinmei-virtual-machine:~$ ping 192.168.137.1
                                PING 192.168.137.1 (192.168.137.1) 56(84) bytes of data.
                                64 字节，来自 192.168.137.1: icmp_seq=1 ttl=128 时间=0.451 毫秒
                                64 字节，来自 192.168.137.1: icmp_seq=2 ttl=128 时间=0.455 毫秒
                                ^C
                                --- 192.168.137.1 ping 统计 ---
                                已发送 29 个包， 已接收 29 个包, 0% 包丢失, 耗时 28383 毫秒
                                rtt 最小/平均/移动平均/最大 = 0.451/0.865/2.067/0.353 ms


                        例 2： ping外网。
                                qinmei@qinmei-virtual-machine:~$ ping www.baidu.com
                                PING www.baidu.com (183.2.172.42) 56(84) bytes of data.
                                64 字节，来自 183.2.172.42 (183.2.172.42): icmp_seq=1 ttl=128 时间=38.1 毫秒
                                64 字节，来自 183.2.172.42 (183.2.172.42): icmp_seq=2 ttl=128 时间=37.3 毫秒
                                64 字节，来自 183.2.172.42 (183.2.172.42): icmp_seq=3 ttl=128 时间=36.6 毫秒
                                64 字节，来自 183.2.172.42 (183.2.172.42): icmp_seq=4 ttl=128 时间=38.8 毫秒
                                ^C
                                --- www.baidu.com ping 统计 ---
                                已发送 5 个包， 已接收 5 个包, 0% 包丢失, 耗时 4008 毫秒
                                rtt 最小/平均/移动平均/最大 = 36.597/37.539/38.779/0.799 ms

                                如果显示%0packet loss (0%包丢失)，就表示可以正常通信。


            1.3.4 子网掩码:
                (主要用于区分ip地址的 网络ID 和 主机ID,这样就能确定当前一个网中最多能分配多少个IP地址，能够连接多少个主机)
                子网掩码(subnet mask)又叫网络掩码、地址掩码 是一个 32bit 由1 和 0组成的 数值，并且1和0分别连续
                作用
                    指明IP 地址中哪些位 标识的是 主机所在的子网 以及 哪些位标识的是 主机号
                特点
                    必须结合IP 地址一起使用，不能单独存在
                    IP 地址中 由子网掩码中1覆盖的连续位 为子网ID,其余为主机 ID

                子网掩码的表现形式
                    192.168.220.0/255.255.255.0  ：在ip地址后面加一个/，直接告诉子网掩码是多少。
                    192.168.220.0/24             ：直接在后面写24，表示有24个连续的1，和8个连续的0组成。

                子网掩码也可以手动配置：
                    在ubuntu中，可以通过 ifconfig 命令即可设置ip地址，又可以设置子网掩码。
                    手动进行配置如下(linux)
                    edu@edu:~S ifconfig eth0 10.0.31.96 netmask 255.255.255.0

              * 默认的子网掩码：
                    A类ip地址的默认的子网掩码为： 255.0.0.0
                    B类ip地址的默认的子网掩码为： 255.255.0.0
                    C类ip地址的默认的子网掩码为： 255.255.255.0

       注释：计算可用主机数量：
        通过子网掩码，可以计算出一个网络中可以容纳的主机数量和可用的IP地址范围。
        其计算公式为： 可用主机数量 = 2^(32 - 子网掩码中1的个数) -2 。
        末尾减去2是因为 一个地址用于网络地址(网段地址)，一个地址用于广播地址（广播地址）。
        如图3所示，在IPv4地址中，一个标准C类地址包含32位，给出255.255.255.0子网掩码，
        网络地址占据前24位，主机地址占据后8位，计算一个C类网络可用的主机数量是2^8-2即256-2=254个。
        由于主机部分有8位，理论地址范围从00000000到11111111，即0到255共256个，全0网络地址和全1广播地址不能分配，因此可用254个。
        全0地址是一个保留地址，被视为网络地址而不是主机地址，全0地址表示不明确的目标网络。

        如图：计算可用主机数量
            一个标准C类地址255.255.255.0 子网掩码

            1111 1111       1111 1111       1111 1111       0000 0000
            《——           网络地址占据前24位       ——》  《—主机地址占据后8位-》

            主机部分有8位
            范围 0000 0000 ~ 1111 1111值，全0网络地址和全1广播地址不能分配
            即 0到255 共256个，可用 254 个。
            可用主机数量 = 2^(32 - 3*8) -2 =2^8 -2 =256 -2 = 254

            1.3.5 端口:(区分一个系统里多少个进程)
                1.3.5.1 端口概述
                  * TCP/IP 协议采用 端口 标识 通信的进程
                  * 用于区分一个系统里的多个进程
                    （我们之前区分进程使用的是进程号，端口和进程号又有何关系？）
                    特点
                        1、对于同一个端口，在不同系统中对应着不同的进程
                        2、对于同一个系统，一个端口只能被一个进程拥有         （一个端口 标识 一个进程）
                        3、一个进程拥有一个端口后，传输层送到该端口的数据全部被该进程接收，同样，进程送交传输层的数据也通过该端口被送出
                        （网络当中传输数据时，数据发给谁和接受谁的数据。通过端口找到唯一的进程）

                1.3.5.2 端口号
                  类似 pid 标识一个进程;在网络程序中，用端口号(port)来标识一个运行的网络程序
                    注意：
                        进程号是系统随机分配的。当一个进程在创建的时候，系统就会随机分配一个进程号。而端口号可以固定下来，无论运行多少次程序，进程号可变，端口号不变。
                        所以端口号主要是用来通信的，同时也可以用来标识一个进程。

                    特点
                        1、端口号是无符号短整型的类型
                        2、每个端口都拥有一个端口号
                        3、一个进程拥有一个端口后，传输层送到该端口的数据全部被该进程接收，同样，进程送交 传输层的数据 也通过该端口被送出.
                        4.、TCP、UDP维护各自独立的端口号
                        5、网络应用程序，至少要占用一个端口号，也可以同时占有多个端口号

                    端口号的分配问题：

                        知名端口（1~1023）
                            由互联网数字分配机构（IANA）根据用户需要进行统一分配
                            例如:FTP-21，HTTP-80等
                            服务器通常使用的范围;
                            若强制使用,须加root特权
                        动态端口(1024~65535)
                            应用程序通常使用的范围
                            一般我们使用的端口号就在这个范围，如：6666、7777、8888、9999、10000、10001
                        注意
                            端口号类似于进程号，同一时刻只能标志一个进程
                            可以重复使用

        1.4 数据包的组装和拆解
            1.4.1 数据包在各个层之间的传输
                见图：
                    由图已知指定好了目的地址的ip地址和目的的端口号。目的的ip地址是192.168.220.3，端口号是7433
                    ip地址是可以确定对方主机的，端口号是确定对方主机里面到底是哪一个进程才是接收方。
                    然后应用层数据就要到达传输层。 就会在应用层数据的前面会加一个头部（TCP或UDP头，含有目的的端口号等数据）组成第一个网络包，再把该包发给网络层。
                    网络层会在传输层的数据包的基础上添加IP头（含有目的的IP地址）构成第二个数据包，然后发给链路层
                    数据链路层 在网络层的数据包的基础上 增加了以太网头部（比特流帧头）。
                    因此到达链路层后，给对方发的是整个一个数据包：

                    接收方首先在 数据链路层对此以太网层，看一下目的MAC地址和接收方的MAC地址是否是同一个。若是，则去掉以太网头，并将网络层数据包发送到网络层
                    到达网络层后，再对比IP头，看目的IP地址是否与接收应用进程的IP地址一致，若一致，则去掉IP头，再将数据传输到传输层
                    传输层再对比目的端口号，端口号一致则去掉TCP/UDP头。最终将数据发送到接收端的应用层。


                                以太网头部 |  IPv4头部 | TCP/UDP头部 |用户数据
    DstMAC=00:0a:95:79:bc:b4帧类型=0800                DstPort=7433
                    DstIP=192.168.220.3协议=TCP/UDO



          * 1.4.2 链路层封包格式:
                    两种格式：IEEE 和 以太网格式。大多使用以太网格式。
                            目的地址：目的MAC地址。
                            源地址  ：源（自己的）MAC 地址(MAC地址是 6个字节；IP地址是 4个字节)，
                            类型    ：决定了 以太网头 后面跟的是什么协议。 （2个字节 4位16进制数）
                                       如果是 0x0800 就是 IP协议
                                       如果是 0x0806 就是ARP请求/应答
                                       如果是 0x0835 就是RARP请求/应答


            IEEE802.2/802.3 封装
                                    | 目的地址 | 源地址 | 长度 | DSAPAA | SSAPAA | Cntl 03 | Org code 00 | 类型 |      数据      | CRC |
                                         6        6       2      1        1         1           3         2     38  ~ 1492       4

                    以太网格式        | 目的地址 | 源地址 | 类型 |                          数据                                   | CRC |
                                         6        6       2                         46  ~ 1500                                   4


                                                                                0x0800| IP数据包
                                                                    类型 ： {    0x0806| ARP请求/应答
                                                                                0x0835|RARP请求/应答
                    注意：
                        1.IEEE802.2/802.3封装常用在无线
                        2.以太网封装常用在有线局域网。


          * 1.4.3 网络层、传输层封包格式:
                当以太网封装 的类型位0x0800,则表示IP数据包，对应网络层。

                IP数据包的头部占20个字节，每一行都是4个字节

        IP数据包：
               ------------------------------------------
               | 版本 | 首部长度 | 服务类型 |      总长度   |        --4字节   总长度：首部长度（原本头的长度）+数据部分长度
               ------------------------------------------
               |      标识                |标志| 分段偏移量|        --4字节
               ------------------------------------------                             1:ICMP
               |      生存期    |    协议  |   包头校验和  |                  协议分为 {  2:IGMP
               ------------------------------------------                             6:TCP
               |                源IP地址                 |                            17:UDP
               ------------------------------------------
               |                目的IP地址               |
               ------------------------------------------
               |                IP选项（可选）            |
               ------------------------------------------
               |                                        |
               |                数据                    |
               |                                        |
                -----------------------------------------

                IP的数据部分：
                        UDP数据包：
                                ----------------------------------------
                                |      源端口      |       目的端口      |
                                ----------------------------------------
                                |       长度       |      UDP校验和     |
                                ----------------------------------------
                                |                                      |
                                |               数据                    |
                                |                                      |
                                ----------------------------------------

                        TCP数据包：
                                ---------------------------------------
                                |     源端口       |       目的端口     |
                                ---------------------------------------
                                |               序号                   |
                                ---------------------------------------
                                |               确认号                 |
                                ---------------------------------------
                                | 首部长度 | 保留 | 代码位 |     窗口    |
                                ---------------------------------------
                                |          校验和        |   紧急指针   |
                                ---------------------------------------
                                |       选项（如果有的话）        | 填充 |
                                ---------------------------------------
                                |                                     |
                                |               数据                   |
                                |                                     |
                                ---------------------------------------


        1.5 网络应用程序开发流程:
            1.5.1 TCP————面向连接
                电话系统服务模式的抽象
                每一次完整的数据传输都要经过 建立连接、使用连接、终止连接 的过程
                本质上,连接是一个管道,收发数据不但顺序一致,而且内容相同
                保证数据传输的可靠性

            1.5.2 UDP————面向无连接 (没有 建立连接 和 终止连接的部分，直接将数据发出去)
                邮件系统服务模式的抽象
                每个分组都携带完整的目的地址
                不能保证分组的先后顺序
                不进行分组出错的恢复和重传
                不保证数据传输的可靠性

                无论采用面向连接的还是无连接，两个进程通信过程中，大多采用 C/S 架构（客户端/服务器架构）
                client(客户端) 向 server（服务器） 发出请求,server 接收到后提供相应的服务
                在通信过程中往往都是 client 先发送请求，而 server 等待请求然后进行服务

            1.5.3 C/S架构示例（面向连接）

            公司                              <————— 拨号 —————>                    客户
                                              ————— "喂" —————>
                      技术，分机号：0080       <————— "hi" —————       分机号随机
                                                    ...
                                              <——— "Byebye"————
                                              ———— "Byebye"———>




            服务器                            <————— 连接请求，SYN —————                    客户端
                                              ————— 确认，SYN ACK—————>
                      服务器进程，端口号0080   <————— 确认，ACK —————————       客户端进程，端口号随机
                                                    ......
                                             <————— 01010....01001————>
                                                     ......
                                             <————— 结束连接，FIN———————
                                             —————— 确认，ACK  —————————>

                前三步称为TCP三次握手，只有三次握手成功后才能相互传输数据，发完数据要退出，则需要经历TCP四次挥手。


                server 工作过程（并发服务器讲解）
                    打开一个通信通道 并 告知本地主机,它愿意在一特定端口(如 80)上接收客户请求
                    等待客户请求到达该端口
                    接收客户请求，并发送应答信号,激活一新的线程处理这个客户请求
                    服务完成后,关闭新线程与客户的通信链路

                client 工作过程
                    打开一通信通道并连接到服务器特定端口
                    向服务器发出服务请求,等待并接收应答
                    根据需要继续提出请求
                    请求结束后关闭通信通道并终止

            （服务器是被动连接的，客户端是主动连接的，但服务器必须先运行）
*/

//第二章：UDP编程
/*
    2.1 编程准备--字节序、地址转换
        2.1.1 字节序概述
            字节序概述：
                是指多字节数据的存储顺序
            分类：
                小端格式：将低位字节数据存储在低地址
                大端格式：将高位字节数据存储在低地址
            注意（标识）:
                LSB：低地址
                MSB：高地址

        例：
            对于 int a = 0x 12 34 56 78 ;     对于16进制数，两两一组就是1个字节（8个bit位），靠近0x的是高字节序，远离0x的称之为低字节序。
                     0x     1   2         3   4        5   6        7   8
            1个数为1bit位   0001 0010    0011 0100    0101 0110    0111 1000
            小端存储：0x01地址 存放0x78      0x04地址存储0x12
            大端存储：0x01地址 存放0x01      0x04地址存储0x78

        * 如何判断当前系统的字节序：
        例：
                #include <stdio.h>

                union un
                {
                    int a;
                    char b;
                };

                //判断字节序：存一个16进制数，取低地址，看存储的数据是高字节还是低字节

                int main(int argc, char const *argv[])
                {
                    union un myun;

                    myun.a = 0x12345678;

                    printf("a = %#x\n",myun.a);
                    printf("a = %#x\n",myun.b);
                    if(myun.b == 0x78)
                    {
                        printf("小端存储\n");
                    }
                    else if(myun.b == 0x12)
                    {
                        printf("大端存储\n");
                    }
                    return 0;
                }

        执行结果：
                qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/2_udp$ gcc 01_endian.c
                qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/2_udp$ ./a.out
                a = 0x12345678
                a = 0x78
                小端存储
                qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/2_udp$



        2.1.2 字节序转换函数
    * 特点
        1、网络协议指定了通讯字节序————大端 （无论主机是大端还是小端，网络协议一定是大端存储）
        2、只有在多字节数据处理时才需要考虑字节序
        3、运行在同一台计算机上的进程相互通信时,一般不用考虑字节序
        4、异构计算机之间通讯，需要转换自己的字节序为网络字节序
        在需要字节序转换的时候一般调用特定字节序转换函数

            字节序转换函数：
                    (h(host) to n(network) :主机字节序转换成网络字节序    l：表示长整型，s：表示短整型)
                1. htonl

                2. htons

                    (n(network) to h(host) :网络字节序转换成主机字节序    l：表示长整型，s：表示短整型)
                3. ntohl

                4. ntohs



            2.1.2.1  htonl 函数 （host to network）
            头文件:
                #include <arpa/inet.h>

            uint32_t htonl(uint32_t hostint32);
            功能：
                将32位主机字节序数据转换成网络字节序数据。
            参数：
                hostint32：待转换的32位主机字节序数据
            返回值：
                成功： 返回网络字节序的值。

            2.1.2.2 htons 函数
            头文件:
                #include <arpa/inet.h>

            uint16_t htons(uint16_t hostint16)
            功能:
                将 16 位主机字节序数据转换成网络字节序数据
            参数:
                uintl6_t: unsigned short int
                hostint16:待转换的16 位主机字节序数据
            返回值:
                成功:返回网络字节序的值


        例：
                #include <stdio.h>
                #include <arpa/inet.h>

                //主机字节序转换成网络字节序
                int main(int argc, char const *argv[])
                {
                    int a = 0x12345678; //主机是小端存储，78存在低地址，网络协议是大端存储，12存在低地址，
                    short b= 0x1234;    //

                    printf("小端存储：\n");
                    printf("a = %#x\n",a);
                    printf("b = %#x\n",b);
                    printf("******************\n");
                    printf("大端存储：\n");
                    printf("%#x\n",htonl(a));   //以字节为单位转换 ，0x78563412
                    printf("%#x\n",htons(b));

                    //由执行结果总结：
                    //原本主机对 a 是小端存储，即把0x12345678,的0x78保存在低地址
                    //经过函数变换之后，把16进制数a 从 0x12345678 变成了 新的16进制数 0x78563412,此时主机再对a进行保存时，低地址保存的就是0x12
                    //从而实现，相对于保存0x12345678 的0x78的小端模式 转化为 保存0x12的大端模式。

                // 小端存储：
                // a = 0x12345678
                // b = 0x1234
                // ******************
                // 大端存储：
                // 0x78563412
                // 0x3412

                    return 0;
                }






            2.1.2.3 ntohl 函数
            头文件:
                #include <arpa/inet.h>

            uint16_t ntohl(uint32_t hostint32)
            功能:
                将 32 位网络字节序数据转换成主机字节序数据
            参数:
                uint32_t: unsigned int
                hostint32:待转换的32 位网络字节序数据
            返回值:
                成功:返回主机字节序的值


            2.1.2.4 ntohs 函数

            uint16_t ntohl(uint32_t hostint16)
            功能:
                将 16 位网络字节序数据转换成主机字节序数据
            参数:
                uint16_t: unsigned int
                hostint16:待转换的 16 位网络字节序数据
            返回值:
                成功:返回主机字节序的值



        2.1.6 地址转换函数
            ip地址转换函数。

            IP为什么需要转换？
                人为识别IP地址的时候，其就是一个字符串。如：192.168.3.103
                而计算机在识别的时候，要以整型的形式让计算机识别。因此，需要将该 字符串 转换为 整型数据。
                （人为识别的ip地址是点分十进制的字符串形式，但是计算机或者网络中识别的ip地址是整形数据，所以需要转化）

                计算机相当于用了一个4字节的整数来保存IP地址。
                        103
                        3
                        168
                        192

            2.1.6.1 inet_pton 函数
                字符串 ip 地址转整型数据

                头文件：
                    #include <arpa/inet.h>
                int inet_pton(int family,const char *strptr, void *addrptr);
                功能：
                    将点分十进制数串转换成 32 位无符号整数
                参数：
                    family 协议族
                        AF_INET
                    strptr 点分十进制数串
                    addrptr 32 位无符号整数的地址
                返回值：
                    成功返回 1 、 失败返回其它

            例：
                    #include <stdio.h>
                    #include <arpa/inet.h>
                    int main()
                    {
                        char ip_str[]="192.168.3.103";
                        unsigned int ip_int = 0;
                        unsigned char *ip_p = NULL;

                        //将点分十进制ip地址转化为32位无符号整形数据
                        inet_pton(AF_INET,ip_str,&ip_int);

                        printf("ip_int = %d\n",ip_int);

                        ip_p = (char *)&ip_int;
                        printf("in_uint = %d,%d,%d,%d\n",*ip_p,*(ip_p+1),*(ip_p+2),*(ip_p+3));

                    //执行结果：
                    // ip_int = 1728293056
                    // in_uint = 192,168,3,103

                        return 0;
                    }




            2.1.6.2 inet_ntop 函数
                整型数据转字符串格式 ip 地址
                头文件：
                    #include <arpa/inet.h>
                const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len);
                功能：
                    将 32 位无符号整数转换成点分十进制数串
                参数：
                    family：协议族 AF_INET（协议族 暂时就传 AF_INET）
                    addrptr：32 位无符号整数
                    strptr:点分十进制数串
                    len :strptr 缓存区长度
                        len 的宏定义(ipv4的地址 还是 ipv6的地址)
                            #define INET_ADDRSTRLEN 16 //for ipv4
                            #define INET6_ADDRSTRLEN 46 //for ipv6
                返回值：
                    成功:则返回字符串的首地址
                    失败:返回 NULL


            2.1.6.3 inet_addr()和 inet_ntoa() 函数
                这两个函数只能用于ipv4地址的转换

                头文件：
                    #include <sys/socket.h>
                    #include <netinet/in.h>
                    #include <arpa/inet.h>

                in_addr_t inet_addr(const char *cp)
                功能:
                    将点分十进制ip地址转化为整形数据
                参数:
                    cp:点分十进制的IP地址
                返回值:
                    成功:整形数据


                char * inet_ntoa(struct in_addr in);
                功能:
                    将整形数据转化为点分十进制的ip地址
                参数:
                    in ：保存ip地址的结构体
                返回值：
                    成功：点分十进制的IP地址。




    2.2 UDP 介绍、编程流程
        2.2.1 UDP概述
            UDP 协议(用户数据包协议)
                面向无连接的用户数据报协议，在传输数据前不需要先建立连接:目地主机的运输层收到 UDP 报文后，不需要给出任何确认
            UDP 特点
                1、相比 TCP 速度稍快些
                2、简单的请求/应答应用程序可以使用 UDP
                3、对于海量数据传输不应该使用 UDP
                4、广播和多播应用必须使用 UDP
            UDP 应用
                DNS(域名解析)、NFS(网络文件系统)、RIP(流媒体)等

            一般语音和视频通话都是使用UDP来通信的。


        2.2.2 网络编程接口 socket
            （编程接口：函数）

                网络通信要解决的是 不同主机 进程间的 通信
                    1、首要问题是：网络间进程标识问题
                    2、以及多重协议的识别向题

                20世纪 80年代初，加州大学 Berkeley 分校在 BSD(一个 UNIX 0S 版本)系统内实现了 TCP/IP 协议:其网络程序编程开发接口为 socket
                随着 UNIX 以及类 UNIX 操作系统的广泛应用， socket 成为最流行的网络程序开发接口

                socket 作用
                    提供不同主机上的进程之间的通信
                socket 特点
                    1、socket 也称“套接字”
                    2、是一种 文件描述符 ,代表了一个通信管道的一个端点.(由于是文件描述符，对它的操作本质上还是读写操作)
                    3、类似对文件的操作一样，可以使用 read、write、close 等函数对 socket 套接字进行网络数据的收取和发送等操作
                    4、得到 socket 套接字(描述符)的方法调用 socket()
              * socket分类：
                    1.SOCK_STREAM:流式套接字，用于TCP。
                    2.SOCK_DGRAM：数据报套接字，用于UDP
                    3.SOCK_RAW：原始套接字，对于其它层次的协议操作时需要使用这个类型。



        2.2.3 UDP编程C/S架构（客户端-服务器模型）

                                                            UDP服务器:
                                                            socket()
                                                                |
                                                              bind()
                                                                |
                                                            recvfrom() <————
                                                                |
                   UDP客户端:                                    |           |
                    socket()                             一直阻塞到收到客户
                        |                                       数据
                        |                                       |           |
               ————> sendto()        —— 数据请求——>              |           |
             |          |                                       |
             |          |                                    处理请求
             |          |                                       |           |
             <————  recvfrom()      <———数据应答———          sendto()    ————>
                        |
                      close()

        UDP网络编程流程：
            服务器：
                    创建套接字 socket()
                    将 服务器的IP地址、端口号 与 套接字进行绑定 bind():只有绑定之后，服务器对应的信息才能进行固定，客户端才能找到服务器。
                    接收数据 recvfrom()
                    发送数据 sendto(
            客户端：
                    创建套接字 socket()
                    发送数据 sendto()
                    接收数据 recvfrom()
                    关闭套接字 close()


    2.3 UDP 编程-创建套接字
        2.3.1 创建socket套接字

            头文件：
            #include <sys/socket.h>

            int socket(int family,int type,int protocol);
            功能：
                创建一个用于网络通信的 socket 套接字（描述符）
            参数：
                family:协议族,通信域
                       AF_UNIX  本地通信
                       AF_INET  ipv4网络协议
                       AF_INET6 ipv6网络协议
                       AF_PACKET 底层接口
                       PF_PACKET
                type:套接字类
                       SOCK_STREAM  流式套接字（TCP）
                       SOCK_DGRAM   数据报套接字（UDP）
                        SOCK_RAW    原始套接字（用于链路层）
                protocol:附加协议，如果不需要，则设置为0 (协议类别)(0、IPPROTO_TCP、IPPROTO_UDP 等）
            返回值：
                套接字，成功 返回 文件描述符
                       失败 返回 -1
            特点:
                创建套接字时，系统不会分配端口     (相当于只是创建了一个文件描述符，但文件描述符对应的程序/文件 是没有办法被别人识别和找到的，只有分配了断口之后，才可以被找到。)
                创建的套接字默认属性是主动的，即主动发起服务的请求;当作为服务器时，往往需要修改为被动的


        2.3.2 创建UDP 套接字demo
            例：
                    #include <stdio.h>
                    #include <sys/socket.h>
                    #include <sys/types.h> //宏定义最好加这个头文件
                    #include <stdlib.h>

                    int main(int argc, char const *argv[])
                    {
                        //使用socket函数创建套接字
                        //创建一个用于UDP网络编程的套接字
                        int sockfd;
                        if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
                        {
                            perror("fail to socket");
                            exit(1);
                        }

                        printf("sockfd = %d\n", sockfd);    //sockfd = 3

                        return 0;
                    }
                注意：
                AF_INET:IPv4 协议
                SOCK_DGRAM：数据报套接字
                0：选择所给定的 family 和 type 组合的系统默认值



    2.4 UDP 编程-发送、绑定、接收数据
        2.4.1 IPv4套接字地址结构
            （之所以学这个：如果客户端想和客户端通信，客户端必须知道服务器是谁，或服务器必须知道客户端是谁。想要确定某唯一的一台主机里面的某一个进程，
                我们得需要：1. IP地址 确定主机 2. 端口号，确定对应的进程。所以IP地址和端口号都需要指定。只不过在编程当中，他们被封装在一个结构体里面）
            （在这里我们先看看该结构体长什么样子）


            在网络中经常使用的的结构体sockaddr_in
            通用结构体：sockaddr
            头文件：
                #include <netinet/in.h>

       1.   struct in_addr
            {
                in_addr_t  s_addr;//4 字节            //IP地址
            };

            //在地址转换函数那一节里，s_addr就是IP地址。就是通过该结构体里的s_addr成员来确定IP地址。

       2.   struct sockaddr_in
            {
                sa_family_t sin_family;//2 字节       //协议族
                in_port_t sin_port;//2 字节           //端口号
                struct in_addr sin_addr;//4 字节      //in_addr的成员变量 即s_addr IP地址。
                char sin_zero[8]//8 字节              //填充，无作用
            };

            为了使不同格式地址能被传入套接字函数,地址须要强制转换成通用套接字地址结构
            （原因是因为不同场合所使用的结构体不一样，但是调用的函数却是同一个，所以定义一个通用结构体，当在指定场合
            使用时，在根据要求传入指定的结构体即可;
            也就是说：在网络编程当中使用的结构体称作 sockaddr_in 但如果学习原始套接字，或本地通信时，结构体可能用的不是同一个，但他们调用的函数都是同一个。那么
            我们在调用函数的时候，先定义一个通用的结构体。那么 在什么场合 就使用 你自己固定的结构体。）

            头文件:#include <netinet/in.h>

      3.    struct sockaddr
            {
                sa_family_t sa_family; // 2 字节  //地址族
                char sa_data[14] //14 字节        //char类型的字符数组。
            };

    注意：
        以上 3 个结构在 linux 系统中已经定义



        2.4.2 两种地址结构使用场合
            在定义源地址 和 目的地址结构的时候，选用 struct sockaddr_in;
            例：
                struct sockaddr_in my_addr;
            当调用编程接口函数，且该函数需要传入地址结构时需要用 struct sockaddr 进行强制转换
            例：
                bind(sockfd,(struct sockaddr*)&my_addr,sizeof(my_addr));


        2.4.3 发送数据—sendto 函数
            ssize_t sendto(int sockfd，const void *buf, size_t nbytes,int flags, const struct sockaddr *to, socklen_t addrlen);
            功能：
                向 to 结构体指针中指定的 ip，发送 UDP 数据
            参数：
                sockfd：套接字，文件描述符，socket的返回值。
                buf： 发送数据缓冲区，要发送的数据，指针类型。
                nbytes: 发送数据缓冲区的大小

                flags：设置标志位，一般为 0（阻塞） ； MSG_DONTWAIT 非阻塞
                to：指向目的主机地址结构体的指针sockaddr类型。
                addrlen：to 所指向内容的长度
            注意：
                通过 to 和 addrlen 确定目的地址
                可以发送 0 长度的 UDP 数据包
            返回值：
                成功:发送数据的字符数
                失败: -1


        2.4.4 向“网络调试助手”发送消息
            网络调试助手就相当于服务器，我们自己的代码就是客户端看看客户端向服务器能不能发送数据。

        网络调试助手是windows下的软件，可以模拟UDP和TCP。
            协议类型可以选择：
                    UDP
                    TCP Client
                    TCP Server
            本地主机地址：（本地IP地址）
                    一般情况下可自动设置IP地址，但有时也会出问题，所以最好：
                    使用命令提示符 ipconfig 去查询ip地址。
                        192.168.137.1
            本地端口号就是服务器的端口号，可以任意设置，如默认8080。

            当设置完成，点击连接后。就与服务器连接完成了。相当于此时网络助手就是UDP服务器。

            注意：IP地址不能随便设置，必须是当前Windows的IP地址。

        Ubuntu下客户端的代码编写：
            客户端流程：
                    创建套接字 socket()
                    发送数据 sendto()
                    接收数据 recvfrom()
                    关闭套接字 close()

        程序例：
                // #include <stdio.h> //printf
                // #include <stdlib.h> //exit
                // #include <sys/types.h>
                // #include <sys/socket.h> //socket
                // #include <netinet/in.h> //sockaddr_in
                // #include <arpa/inet.h> //htons inet_addr
                // #include <unistd.h> //close
                // #include <string.h>

                // #define N 128

                // int main(int argc, char const *argv[])
                // {
                //     //第一步：创建套接字
                //     int sockfd;
                //     if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
                //     {
                //         perror("fail to socket");
                //         exit(1);
                //     }

                //     printf("sockfd = %d\n", sockfd);

                //     //第二步：填充服务器网络信息结构体 sockaddr_in
                //     struct sockaddr_in serveraddr;
                //     socklen_t addrlen = sizeof(serveraddr);

                //     serveraddr.sin_family = AF_INET; //协议族，AF_INET：ipv4网络协议
                //     serveraddr.sin_addr.s_addr = inet_addr("192.168.137.1"); //s_addr是32位无符号的整型数据，要使用（inet_addr）将点分十进制的数据转为无符号的十进制数据。ip地址
                //     serveraddr.sin_port = htons(8080);//由于不知道大小端存储，sin_port是unsigned short int类型，所以使用htons 将8080转换为大端存储，

                //     //第三步：发送数据
                //     char buf[N] = "";
                //     while(1)
                //     {
                //         fgets(buf, N, stdin);//终端接受数据
                //         buf[strlen(buf) - 1] = '\0'; //把buf字符串中的\n转化为\0

                //         if(sendto(sockfd, buf, N, 0, (struct sockaddr *)&serveraddr, addrlen) == -1)
                //         {
                //             perror("fail to sendto");
                //             exit(1);
                //         }
                //     }

                //     //第四步：关闭套接字文件描述符
                //     close(sockfd);

                //     return 0;
                // }



                #include <stdio.h> //printf
                #include <stdlib.h> //exit
                #include <sys/types.h>
                #include <sys/socket.h> //socket
                #include <netinet/in.h> //sockaddr_in
                #include <arpa/inet.h> //htons inet_addr
                #include <unistd.h> //close
                #include <string.h>

                #define N 128

                int main(int argc, char const *argv[])
                {
                    //./a.out 192.168.3.78 8080
                    if(argc < 3)
                    {
                        fprintf(stderr, "Usage：%s ip port\n", argv[0]);
                        exit(1);
                    }

                    //第一步：创建套接字
                    int sockfd;
                    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
                    {
                        perror("fail to socket");
                        exit(1);
                    }

                    printf("sockfd = %d\n", sockfd);

                    //第二步：填充服务器网络信息结构体 sockaddr_in
                    struct sockaddr_in serveraddr;
                    socklen_t addrlen = sizeof(serveraddr);

                    serveraddr.sin_family = AF_INET; //协议族，AF_INET：ipv4网络协议
                    serveraddr.sin_addr.s_addr = inet_addr(argv[1]); //s_addr是32位无符号的整型数据，要使用（inet_addr）将点分十进制的数据转为无符号的十进制数据。ip地址
                    serveraddr.sin_port = htons(atoi(argv[2]));//由于不知道大小端存储，sin_port是unsigned short int类型，所以使用htons 将8080转换为大端存储，

                    //第三步：发送数据
                    char buf[N] = "";
                    while(1)
                    {
                        fgets(buf, N, stdin);//终端接受数据
                        buf[strlen(buf) - 1] = '\0'; //把buf字符串中的\n转化为\0

                        if(sendto(sockfd, buf, N, 0, (struct sockaddr *)&serveraddr, addrlen) == -1)
                        {
                            perror("fail to sendto");
                            exit(1);
                        }
                    }

                    //第四步：关闭套接字文件描述符
                    close(sockfd);

                    return 0;
                }



        2.4.5 绑定bind函数
                UDP 网络程序想要收取数据需什么条件？
                    确定的 ip 地址
                    确定的 port端口号
                怎样完成上面的条件呢？
                    接收端 使用 bind 函数，来完成地址结构与 socket 套接字的绑定，这样 ip、port 就固定了
                    发送端 在 sendto 函数中指定接收端的 ip、port，就可以发送数据了

                由于服务器是被动的，客户端是主动的，所以一般先运行服务器，后运行客户端，所以服务器需要固定自己的信息(ip地址和端口号)，
                这样客户端才可以找到服务器并与之通信，但是客户端一般不需要bind绑定，因为系统会自动给客户端分配ip地址和端口号
                (当然，如果实在想要也固定客户端的IP地址和端口号，则客户端也调用bind即可)

                int bind(int sockfd,const struct sockaddr *myaddr，socklen_t addrlen);
                功能：
                    将本地协议地址与 sockfd 绑定
                参数：
                    sockfd： socket 套接字
                    myaddr： 指向特定协议的地址结构指针
                    addrlen：该地址结构的长度
                返回值：
                    成功：返回 0
                    失败：其他


        2.4.6 bind 示例
                    #include <stdio.h> //printf
                    #include <stdlib.h> //exit
                    #include <sys/types.h>
                    #include <sys/socket.h> //socket
                    #include <netinet/in.h> //sockaddr_in
                    #include <arpa/inet.h> //htons inet_addr
                    #include <unistd.h> //close
                    #include <string.h>

                    //bind示例(服务器代码):一般服务器都需要执行bind函数

                    int main(int argc, char const *argv[])
                    {
                        if(argc < 3)
                        {
                            fprintf(stderr, "Usage: %s ip port\n", argv[0]);
                            exit(1);
                        }

                        //第一步：创建套接字
                        int sockfd;
                        if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
                        {
                            perror("fail to socket");
                            exit(1);
                        }

                        //第二步：将服务器的网络信息结构体绑定前进行填充
                        struct sockaddr_in serveraddr;
                        serveraddr.sin_family = AF_INET;
                        serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                        serveraddr.sin_port = htons(atoi(argv[2]));

                        //第三步：将网络信息结构体与套接字绑定
                        if(bind(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) == -1)
                        {
                            perror("fail to bind");
                            exit(1);
                        }

                        return 0;
                    }


        2.4.7 接收数据—recvfrom 函数

            ssize_t recvfrom(int sockfd, void *buf,size_t nbytes,int flags,struct sockaddr *from,socklen_t *addrlen);
            功能：
                接收 UDP 数据（不光UDP，TCP的数据也能接收），并将源地址信息保存在 from 指向的结构中
            参数：
                sockfd: 套接字
                buf：接收数据缓冲区
                nbytes:接收数据缓冲区的大小
                flags： 套接字标志(常为 0)
                from： 源地址结构体指针，用来保存数据的来源
                addrlen: from 所指内容的长度
            注意：
                通过 from 和 addrlen 参数存放数据来源信息
                from 和 addrlen 可以为 NULL, 表示不保存数据来源
            返回值：
                成功:接收到的字符数
                失败: -1



        2.4.8 接收“网络调试助手”的数据
            此时网络调试助手作为客户端，ubuntu的程序作为服务器
            设置网络调试助手
                协议类型还是UDP
                本地IP地址：windows下的主机地址ipconfig查到的地址 192.168.137.1
                本地端口号：8080随便设置

                有下方：目标主机：ubuntu下的 inet(ipv4): 192.168.177.128  地址必须是真实的。
                       目标端口：9999随便设置

            设置服务器Ubuntu下的程序：

                    #include <stdio.h> //printf
                    #include <stdlib.h> //exit
                    #include <sys/types.h>
                    #include <sys/socket.h> //socket
                    #include <netinet/in.h> //sockaddr_in
                    #include <arpa/inet.h> //htons inet_addr
                    #include <unistd.h> //close
                    #include <string.h>

                    #define N 128

                    int main(int argc, char const *argv[])
                    {
                        if(argc < 3)
                        {
                            fprintf(stderr, "Usage: %s ip port\n", argv[0]);
                            exit(1);
                        }

                        //第一步：创建套接字
                        int sockfd;
                        if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
                        {
                            perror("fail to socket");
                            exit(1);
                        }

                        //第二步：将服务器的网络信息结构体绑定前进行填充
                        struct sockaddr_in serveraddr;
                        serveraddr.sin_family = AF_INET;
                        serveraddr.sin_addr.s_addr = inet_addr(argv[1]); //192.168.3.103
                        serveraddr.sin_port = htons(atoi(argv[2])); //9999

                        //第三步：将网络信息结构体与套接字绑定
                        if(bind(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) == -1)
                        {
                            perror("fail to bind");
                            exit(1);
                        }

                        //接收数据
                        char buf[N] = "";
                        struct sockaddr_in clientaddr;
                        socklen_t addrlen = sizeof(struct sockaddr_in);
                        while(1)
                        {
                            if(recvfrom(sockfd, buf, N, 0, (struct sockaddr *)&clientaddr, &addrlen) == -1)
                            {
                                perror("fail to recvfrom");
                                exit(1);
                            }

                            //打印数据
                            //打印客户端的ip地址和端口号
                            printf("ip:%s, port:%d\n", inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));
                            //打印接收到数据
                            printf("from client: %s\n", buf);
                        }

                        return 0;
                    }

            执行结果：
                qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/2_udp$ ./a.out 192.168.177.128 9999
                ip:192.168.177.1, port:8080
                from client: hello
                ip:192.168.177.1, port:8080
                from client: hello
                ip:192.168.177.1, port:8080
                from client: hello

            调试助手的IP 及 端口： 192.168.177.1/8080
            虚拟机  的IP 及 端口： 192.168.177.128/9999


    2.5 UDP编程-client、server
        想一想:
            上节中的2个 demo 中 发送数据端 其实就是 client;
            接收数据端就是 server，那么 client 能否接收数据?server能否发送数据呢?
        答：
            其实在网络编程开发中 client 和 server 双方既可以有发送数据还可以接收数据:一般认为提供服务的一方为
            server;而接受服务的另一方为client


        2.5.1 回顾UDP编程C/S架构（客户端-服务器模型）

                                                            UDP服务器:
                                                            socket()
                                                                |
                                                              bind()
                                                                |
                                                            recvfrom() <————
                                                                |
                   UDP客户端:                                    |           |
                    socket()                             一直阻塞到收到客户
                        |                                       数据
                        |                                       |           |
               ————> sendto()        —— 数据请求——>              |           |
             |          |                                       |
             |          |                                    处理请求
             |          |                                       |           |
             <————  recvfrom()      <———数据应答———          sendto()    ————>
                        |
                      close()


        2.5.2 UDP客户端注意点：
            1、本地 IP、本地端口（我是谁）
            2、目的 IP、目的端口（发给谁）
            3、在客户端的代码中，我们只设置了目的 IP、目的端口

            客户端的本地 ip、本地 port 是我们调用 sendto 的时候 linux 系统底层自动给客户端分配的；分配端口的方
            式为随机分配，即每次运行系统给的 port 不一样

        例（完整版客户端）：
                    //udp客户端的实现
                    #include <stdio.h> //printf
                    #include <stdlib.h> //exit
                    #include <sys/types.h>
                    #include <sys/socket.h> //socket
                    #include <netinet/in.h> //sockaddr_in
                    #include <arpa/inet.h> //htons inet_addr
                    #include <unistd.h> //close
                    #include <string.h>

                    int main(int argc, char const *argv[])
                    {
                        if(argc < 3)
                        {
                            fprintf(stderr, "Usage: %s <ip> <port>\n", argv[0]);
                            exit(1);
                        }

                        int sockfd; //文件描述符
                        struct sockaddr_in serveraddr; //服务器网络信息结构体
                        socklen_t addrlen = sizeof(serveraddr);

                        //第一步：创建套接字
                        if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
                        {
                            perror("fail to socket");
                            exit(1);
                        }

                        //客户端自己指定自己的ip地址和端口号，一般不需要，系统会自动分配
                    #if 0
                        struct sockaddr_in clientaddr;
                        clientaddr.sin_family = AF_INET;
                        clientaddr.sin_addr.s_addr = inet_addr(argv[3]); //客户端的ip地址
                        clientaddr.sin_port = htons(atoi(argv[4])); //客户端的端口号
                        if(bind(sockfd, (struct sockaddr *)&clientaddr, addrlen) < 0)
                        {
                            perror("fail to bind");
                            exit(1);
                        }
                    #endif

                        //第二步：填充服务器网络信息结构体
                        //inet_addr：将点分十进制字符串ip地址转化为整形数据
                        //htons：将主机字节序转化为网络字节序
                        //atoi：将数字型字符串转化为整形数据
                        serveraddr.sin_family = AF_INET;
                        serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                        serveraddr.sin_port = htons(atoi(argv[2]));

                        //第三步：进行通信
                        char buf[32] = "";
                        while(1)
                        {
                            fgets(buf, sizeof(buf), stdin);
                            buf[strlen(buf) - 1] = '\0';

                            if(sendto(sockfd, buf, sizeof(buf), 0, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0)
                            {
                                perror("fail to sendto");
                                exit(1);
                            }

                            char text[32] = "";
                            if(recvfrom(sockfd, text, sizeof(text), 0, (struct sockaddr *)&serveraddr, &addrlen) < 0)
                            {
                                perror("fail to recvfrom");
                                exit(1);
                            }
                            printf("from server: %s\n", text);
                        }
                        //第四步：关闭文件描述符
                        close(sockfd);

                        return 0;
                    }



        2.5.2 UDP服务器注意点：
            1、服务器之所以要 bind 是因为它的本地 port 需要是固定，而不是随机的
            2、服务器也可以主动地给客户端发送数据
            3、客户端也可以用 bind，这样客户端的本地端口就是固定的了，但一般不这样做

        例：
                    //udp服务器的实现
                    #include <stdio.h> //printf
                    #include <stdlib.h> //exit
                    #include <sys/types.h>
                    #include <sys/socket.h> //socket
                    #include <netinet/in.h> //sockaddr_in
                    #include <arpa/inet.h> //htons inet_addr
                    #include <unistd.h> //close
                    #include <string.h>

                    int main(int argc, char const *argv[])
                    {
                        if(argc < 3)
                        {
                            fprintf(stderr, "Usage: %s <ip> <port>\n", argv[0]);
                            exit(1);
                        }

                        int sockfd; //文件描述符
                        struct sockaddr_in serveraddr; //服务器网络信息结构体
                        socklen_t addrlen = sizeof(serveraddr);

                        //第一步：创建套接字
                        if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
                        {
                            perror("fail to socket");
                            exit(1);
                        }

                        //第二步：填充服务器网络信息结构体
                        //inet_addr：将点分十进制字符串ip地址转化为整形数据
                        //htons：将主机字节序转化为网络字节序
                        //atoi：将数字型字符串转化为整形数据
                        serveraddr.sin_family = AF_INET;
                        serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                        serveraddr.sin_port = htons(atoi(argv[2]));

                        //第三步：将套接字与服务器网络信息结构体绑定
                        if(bind(sockfd, (struct sockaddr *)&serveraddr, addrlen) < 0)
                        {
                            perror("fail to bind");
                            exit(1);
                        }

                        while(1)
                        {
                            //第四步：进行通信
                            char text[32] = "";
                            struct sockaddr_in clientaddr;
                            if(recvfrom(sockfd, text, sizeof(text), 0, (struct sockaddr *)&clientaddr, &addrlen) < 0)
                            {
                                perror("fail to recvfrom");
                                exit(1);
                            }
                            printf("[%s - %d]: %s\n", inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port), text);

                            strcat(text, " *_*");

                            if(sendto(sockfd, text, sizeof(text), 0, (struct sockaddr *)&clientaddr, addrlen) < 0)
                            {
                                perror("fail to sendto");
                                exit(1);
                            }
                        }

                        //第四步：关闭文件描述符
                        close(sockfd);

                        return 0;
                    }




















*/

//第三章 UDP编程——TFTP、广播、多播
/*
    3.1 TFTP简介、通信过程
        3.1.1 TFTP概述
            (实现对文件的下载和上传的功能  FTP（基于TCP）:（大）文件传输协议  TFTP（基于UDP）:简单文件传输协议)
            TFTP：简单文件传送协议
                最初用于引导无盘系统，被设计用来传输小文件
            特点：
                基于 UDP 协议实现
                不进行用户有效性认证
            数据传输模式：
                octet：二进制模式
                netascii：文本模式
                mail：已经不再支持

        3.1.2 TFTP通信过程
            见图.

            对流程图的说明：客户端首先有一个临时的端口号（port） 7788, 然后向服务器发送一个下载指令，若TFTP（服务器）原本的端口号是69
            那么当服务器收到客户端发过来的指令之后，服务器会做一系列的判断，如：客户端是要下载服务器的文件。此时，服务器会重新再创建一个端口（12345），重新开端口主要是为了实现 并发,即并行操作。
            然后临时端口就会把数据包（默认512个字节）发给客户端，客户端收到数据包后回复一个应答（ACK），ACK的参数就是第几次收到的数据包。当客户端最后接收到的数据包小于512个字节之后，再回复ACK后，服务器就不会再发送数据了。

            TFTP 通信过程总结
                1、服务器在 69 号端口等待客户端的请求
                2、服务器若批准此请求,则使用临时端口与客户端进行通信
                3、每个数据包的编号都有变化（从 1 开始）
                4、每个数据包都要得到 ACK 的确认如果出现超时,则需要重新发送最后的包（数据或 ACK）
                5、数据的长度以 512Byte 传输
                6、小于 512Byte 的数据意味着传输结束

    3.2 TFTP 协议分析
        详细见手册：(主要用前4个)

                    由于操作码是2B所以传01（下载） / 02（上传）
            读写请求    |操作码1/2 （RD/WR）| 文件名| 0 | 模式 | 0 | 选项1 | 0 | 值1 | 0 | ... |选项n | 0 | 值n | 0 |
                            2Byte    nByte string  1B  nBS  1B     nBS   1B  NBS  1B

                          03      第一次发数据包则为01
            数据包      |操作码3（DATA）| 块编号 |     数据      |
                            2BS         2B        512 B Data

                          04            接收到的几就回几
            ACK        |操作码4（ACK）|  块编号 |
                            2B          2B

                          05
            ERROR      |操作码5（ERR）|  差错码 | 差错信息 |  0  |
                            2B          2B       nBS      1B

                            06
            OAACK      |操作码6(OACK）| 选项1 |0| 值1 |0|... | 选项n |0| 值n |0|
                            2B          nBS  1B  nBS 1B      nBS   1B  nBS 1B

         注意：
            以上的 0 代表的是'\0' 不同的差错码对应不同的错误信息
        错误码：
            0 未定义,参见错误信息
            1 File not found.
            2 Access violation.
            3 Disk full or allocation exceeded.
            4 illegal TFTP operation.
            5 Unknown transfer ID.
            6 File already exists.
            7 No such user.
            8 Unsupported option(s) requested.

    3.3 练习—TFTP 客户端
        练习要求
            使用 TFTP 协议，下载 server 上的文件到本地
        实现思路
            1、构造请求报文，送至服务器(69 号端口)
            2、等待服务器回应
            3、分析服务器回应
            4、接收数据,直到接收到的数据包小于规定数据长度

        服务器端事先通过准备好的软件来使用，如：设置服务器的IP地址（Windows的IP地址）
        客户端编写代码：
                见流程图
        注意：
            1.tftp的服务器端口号默认就是69，不需要设置
            2.代码需要传tftp的服务器IP地址，在此是windows的IP地址：192.168.137.1


        TFTP下载：
                    #include <stdio.h> //printf
                    #include <stdlib.h> //exit
                    #include <sys/types.h>
                    #include <sys/socket.h> //socket
                    #include <netinet/in.h> //sockaddr_in
                    #include <arpa/inet.h> //htons inet_addr
                    #include <unistd.h> //close
                    #include <string.h>
                    #include <sys/stat.h>
                    #include <fcntl.h>

                    void do_download(int sockfd, struct sockaddr_in serveraddr)
                    {
                        char filename[128] = "";
                        printf("请输入要下载的文件名: ");
                        scanf("%s", filename);

                        //给服务器发送消息，告知服务器执行下载操作
                        unsigned char text[1024] = "";
                        int text_len;
                        socklen_t addrlen = sizeof(struct sockaddr_in);
                        int fd;
                        int flags = 0;
                        int num = 0;
                        ssize_t bytes;

                        //构建给服务器发送的tftp指令并发送给服务器，例如：01test.txt0octet0
                        text_len = sprintf(text, "%c%c%s%c%s%c", 0, 1, filename, 0, "octet", 0);
                        if(sendto(sockfd, text, text_len, 0, (struct sockaddr *)&serveraddr, addrlen) < 0)
                        {
                            perror("fail to sendto");
                            exit(1);
                        }

                        while(1)
                        {
                            //接收服务器发送过来的数据并处理
                            if((bytes = recvfrom(sockfd, text, sizeof(text), 0, (struct sockaddr *)&serveraddr, &addrlen)) < 0)
                            {
                                perror("fail to recvfrom");
                                exit(1);
                            }

                            //printf("操作码：%d, 块编号：%u\n", text[1], ntohs(*(unsigned short *)(text+2)));
                            //printf("数据：%s\n", text+4);

                            //判断操作码执行相应的处理
                            if(text[1] == 5)
                            {
                                printf("error: %s\n", text+4);
                                return ;
                            }
                            else if(text[1] == 3)
                            {
                                if(flags == 0)
                                {
                                    //创建文件
                                    if((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0664)) < 0)
                                    {
                                        perror("fail to open");
                                        exit(1);
                                    }
                                    flags = 1;  //文件被成功打开的标志位。
                                }

                                //对比编号和接收的数据大小并将文件内容写入文件
                                if((num+1 == ntohs(*(unsigned short *)(text+2))) && (bytes == 516)) //这里判断数据是否为516而不是512是因为：数据包 = 2Byte操作码 + 2Byte块编号 + 512字节数据
                                {
                                    num = ntohs(*(unsigned short *)(text+2));
                                    if(write(fd, text + 4, bytes - 4) < 0)
                                    {
                                        perror("fail to write");
                                        exit(1);
                                    }

                                    //当文件写入完毕后，给服务器发送ACK
                                    text[1] = 4;
                                    if(sendto(sockfd, text, 4, 0, (struct sockaddr *)&serveraddr, addrlen) < 0)
                                    {
                                        perror("fail to sendto");
                                        exit(1);
                                    }
                                }
                                //当最后一个数据接收完毕后，写入文件后退出函数
                                else if((num+1 == ntohs(*(unsigned short *)(text+2))) && (bytes < 516))
                                {
                                    if(write(fd, text + 4, bytes - 4) < 0)  //byte是数据包的大小，写入的数据的大小 = 数据包大小 - 4Byte
                                    {
                                        perror("fail to write");
                                        exit(1);
                                    }

                                    text[1] = 4;
                                    if(sendto(sockfd, text, 4, 0, (struct sockaddr *)&serveraddr, addrlen) < 0)
                                    {
                                        perror("fail to sendto");
                                        exit(1);
                                    }

                                    printf("文件下载完毕\n");
                                    return ;
                                }
                            }
                        }
                    }

                    int main(int argc, char const *argv[])
                    {
                        if(argc < 2)
                        {
                            fprintf(stderr, "Usage: %s <server_ip>\n", argv[0]);
                            exit(1);
                        }

                        int sockfd;
                        struct sockaddr_in serveraddr;

                        //创建套接字
                        if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
                        {
                            perror("fail to socket");
                            exit(1);
                        }

                        //填充服务器网络信息结构体
                        serveraddr.sin_family = AF_INET;
                        serveraddr.sin_addr.s_addr = inet_addr(argv[1]); //tftp服务器端的ip地址，192.168.3.78
                        serveraddr.sin_port = htons(69); //tftp服务器的端口号默认是69

                        do_download(sockfd, serveraddr); //下载操作

                        return 0;
                    }

        TFTP 上传：
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <unistd.h>
                    #include <sys/types.h>
                    #include <sys/socket.h>
                    #include <arpa/inet.h>
                    #include <netinet/in.h>
                    #include <string.h>
                    #include <sys/stat.h>
                    #include <fcntl.h>
                    #include <errno.h>

                    #define ERRLOG(errmsg) do{\
                                                perror(errmsg);\
                                                exit(1);\
                                            }while(0)

                    #define N 128

                    void do_help()
                    {
                        system("clear");
                        printf("---------------------\n");
                        printf("------ 1. 下载 ------\n");
                        printf("------ 2. 上传 ------\n");
                        printf("------ 3. 退出 ------\n");
                        printf("---------------------\n");
                    }

                    void do_download(int sockfd, struct sockaddr_in serveraddr)
                    {
                        char filename[N] = {};
                        printf("请输入要下载的文件名：");
                        scanf("%s", filename);

                        char data[1024] = "";
                        int data_len;
                        int fd;
                        int flags = 0;
                        int num = 0;
                        int recv_len;

                        //组数据并发送
                        data_len = sprintf(data, "%c%c%s%c%s%c", 0, 1, filename, 0, "octet", 0);
                        if(sendto(sockfd, data, data_len, 0, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0)
                        {
                            ERRLOG("fail to sendto");
                        }

                        //接收数据并分析处理
                        socklen_t addrlen = sizeof(serveraddr);
                        while(1)
                        {
                            if((recv_len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr *)&serveraddr, &addrlen)) < 0)
                            {
                                ERRLOG("fail to recvfrom");
                            }

                            //printf("%d - %u\n", data[1], ntohs(*(unsigned short *)(data + 2)));
                            //printf("%s\n", data + 4);

                            if(data[1] == 5)
                            {
                                printf("error: %s\n", data + 4);
                                return ;
                            }
                            else if(data[1] == 3)
                            {
                                //防止文件内容清空
                                if(flags == 0)
                                {
                                    if((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0664)) < 0)
                                    {
                                        ERRLOG("fail to open");
                                    }
                                    flags = 1;
                                }

                                //判断数据包的编号是否是上一次的编号加1
                                if(num + 1 == ntohs(*(unsigned short *)(data + 2)) && recv_len == 516)
                                {
                                    //向文件写入数据
                                    write(fd, data + 4, recv_len - 4);

                                    //组数据发送给服务器
                                    data[1] = 4;
                                    if(sendto(sockfd, data, 4, 0, (struct sockaddr *)&serveraddr, addrlen) < 0)
                                    {
                                        ERRLOG("fail to sendto");
                                    }

                                    num = ntohs(*(unsigned short *)(data + 2));
                                }
                                //接收到的最后一次的数据
                                else if(num + 1 == ntohs(*(unsigned short *)(data + 2)) && recv_len < 516)
                                {
                                    write(fd, data + 4, recv_len - 4);
                                    break;
                                }
                            }
                        }

                        printf("文件下载成功\n");
                    }

                    void do_upload(int sockfd, struct sockaddr_in serveraddr)
                    {
                        char filename[N] = {};
                        printf("请输入要上传的文件名：");
                        scanf("%s", filename);

                        //打开文件并判断文件是否存在
                        int fd;
                        if((fd = open(filename, O_RDONLY)) < 0)
                        {
                            if(errno == ENOENT)
                            {
                                printf("文件%s不存在，请重新输入\n", filename);
                                return ;
                            }
                            else
                            {
                                ERRLOG("fail to open");
                            }
                        }

                        //组数据并发送给服务器执行上传功能
                        char data[1024] = {};
                        int data_len;
                        socklen_t addrlen = sizeof(serveraddr);

                        data_len = sprintf(data, "%c%c%s%c%s%c", 0, 2, filename, 0, "octet", 0);

                        if(sendto(sockfd, data, data_len, 0, (struct sockaddr *)&serveraddr, addrlen) < 0)
                        {
                            ERRLOG("fail to sendto");
                        }

                        //接收服务器发送的数据并分析处理
                        int recv_len;
                        int num = 0;
                        ssize_t bytes;
                        while(1)
                        {
                            if((recv_len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr *)&serveraddr, &addrlen)) < 0)
                            {
                                ERRLOG("fail to recvfrom");
                            }

                            //printf("%d - %d\n", data[1], ntohs(*(unsigned short *)(data + 2)));
                            //printf("%s\n", data + 4);

                            if(data[1] == 4 && num == ntohs(*(unsigned short *)(data + 2)))
                            {
                                num++;
                                bytes = read(fd, data + 4, 512);
                                data[1] = 3;
                                *(unsigned short *)(data + 2) = htons(num);

                                if(bytes == 512)
                                {
                                    if(sendto(sockfd, data, bytes + 4, 0, (struct sockaddr *)&serveraddr, addrlen) < 0)
                                    {
                                        ERRLOG("fail to sendto");
                                    }
                                }
                                else
                                {
                                    if(sendto(sockfd, data, bytes + 4, 0, (struct sockaddr *)&serveraddr, addrlen) < 0)
                                    {
                                        ERRLOG("fail to sendto");
                                    }
                                    break;
                                }
                            }
                        }

                        printf("文件上传完毕\n");
                    }

                    int main(int argc, char const *argv[])
                    {
                        int sockfd;
                        struct sockaddr_in serveraddr;
                        //创建套接字
                        if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
                        {
                            ERRLOG("fail to socket");
                        }

                        //填充服务器网络信息结构体
                        serveraddr.sin_family = AF_INET;
                        serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                        serveraddr.sin_port = htons(69);

                        system("clear");
                        printf("------------------------------\n");
                        printf("----请输入help查看帮助信息----\n");
                        printf("------------------------------\n");
                        printf(">>> ");

                        char buf[N] = {};
                    NEXT:
                        fgets(buf, N, stdin);
                        buf[strlen(buf) - 1] = '\0';
                        if(strncmp(buf, "help", 4) == 0)
                        {
                            do_help();
                        }
                        else
                        {
                            printf("您输入的有误，请重新输入\n");
                            goto NEXT;
                        }

                        int num;
                        while(1)
                        {
                            printf("input>>> ");
                            scanf("%d", &num);
                            switch (num)
                            {
                            case 1:
                                do_download(sockfd, serveraddr);
                                break;
                            case 2:
                                do_upload(sockfd, serveraddr);
                                break;
                            case 3:
                                close(sockfd);
                                exit(0);
                                break;
                            default:
                                printf("您输入的有误，请重新输入\n");
                                break;
                            }
                        }

                        return 0;
                    }



    3.4 UDP广播
        3.4.1 广播的概念
            网络中的广播：
                广播：由一台主机 向该主机所在子网内的所有主机 发送数据的方式
                    例：192.168.3.103主机发送广播信息，则192.168.3.1 ~ 192.168.3.254 所有主机都可以接收到数据。
                广播只能用 UDP 或原始 IP 实现，不能用 TCP

            3.4.1.1 广播的用途

                单个服务器与多个客户主机通信时减少分组流通
                以下几个协议都用到广播
                    1、地址解析协议（ARP）
                    2、动态主机配置协议（DHCP）
                    3、网络时间协议（NTP）

        3.4.2 UDP 广播的特点
            1、处于同一子网的所有主机都必须处理数据
            2、UDP 数据包会沿协议栈向上一直到 UDP 层
            3、运行音视频等较高速率工作的应用，会带来大负荷
            4、局限于局域网内使用

        3.4.3 UDP 广播地址：每一个网段对后一个地址 就是广播地址 如：192.168.3.255
            {网络 ID，主机 ID}
                网络 ID 表示由子网掩码中 1 覆盖的连续位
                主机 ID 表示由子网掩码中 0 覆盖的连续位
            定向广播地址：主机 ID 全 1
                1、例：对于 192.168.220.0/24网段，其定向广播地址为 192.168.220.255
                2、 通常 路由器不转发该广播

            受限广播地址：255.255.255.255
                路由器 从不转 发该广播

        3.4.4 广播 与 单播的对比
            单播的IP地址可以是任意的，其目的机的MAC地址：指定对方的MAC地址。
            而广播地址必须是 .255    其目的地址不是指定的MAC地址，而是广播对应的MAC地址。  而广播对应的MAC地址全是f,即：DstMAC=ff ff ff ff ff ff


        3.4.5 广播流程：
            发送者：
                1.使用socket创建套接字。
                2.设置为允许发送广播权限setsockopt()
                3.向广播地址（IP地址是广播的IP地址） 发送数据sendto()

            接收者：
                1.使用socket创建套接字
                2.将套接字与 广播的信息结构体 绑定bind()
                3.接收数据 recvfrom()

        3.4.6 套接口选项
            比UDP多了一个：需要设置能够发送广播。所以需要用到setsockopt函数。
            int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
            功能：
                设置为允许发送广播的数据。
            参数：
                sockfd:文件描述符
                level:等级层次
                        SOL_SOCKET      套接字层次
                        IPPROTO_TCP     tcp层次
                        IPPROTO_IP      IP层次
                optname:选项的名字
                        SO_BROADCAST：允许发送广播数据包（SOL_SOCKET层次的）
                        SO_RCVBUF：接收缓冲区大小
                        SO_SNDBUF：发送缓冲区大小
                optval：选项的值，
                        类型：int类型的值，存储的是bool的数据（1和0）
                                0 不允许
                                1 允许
                optlen：选项的大小。optval的长度
            返回值:
                成功返回0
                失败返回-1



        3.4.7 广播示例：
            3.4.7.1 发送者：
                    //广播发送者代码实现
                    #include <stdio.h> //printf
                    #include <stdlib.h> //exit
                    #include <sys/types.h>
                    #include <sys/socket.h> //socket
                    #include <netinet/in.h> //sockaddr_in
                    #include <arpa/inet.h> //htons inet_addr
                    #include <unistd.h> //close
                    #include <string.h>

                    int main(int argc, char const *argv[])
                    {
                        if(argc < 3)
                        {
                            fprintf(stderr, "Usage: %s <ip> <port>\n", argv[0]);
                            exit(1);
                        }

                        int sockfd; //文件描述符
                        struct sockaddr_in broadcataddr; //服务器网络信息结构体
                        socklen_t addrlen = sizeof(broadcataddr);

                        //第一步：创建套接字
                        if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
                        {
                            perror("fail to socket");
                            exit(1);
                        }

                        //第二步：设置为允许发送广播权限
                        int on = 1;
                        if(setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on)) < 0)
                        {
                            perror("fail to setsockopt");
                            exit(1);
                        }

                        //第三步：填充广播信息结构体
                        broadcataddr.sin_family = AF_INET;
                        broadcataddr.sin_addr.s_addr = inet_addr(argv[1]); //192.168.3.255 255.255.255.255
                        broadcataddr.sin_port = htons(atoi(argv[2]));

                        //第四步：进行通信
                        char buf[128] = "";
                        while(1)
                        {
                            fgets(buf, sizeof(buf), stdin);
                            buf[strlen(buf) - 1] = '\0';

                            if(sendto(sockfd, buf, sizeof(buf), 0, (struct sockaddr *)&broadcataddr, addrlen) < 0)
                            {
                                perror("fail to sendto");
                                exit(1);
                            }
                        }

                        return 0;
                    }
            执行结果：
                qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/3_tftp_broadcast_groupcast$ ./send 192.168.177.255 9999
                nihao
                hello


            3.4.7.2 接收者：
                    #include <stdio.h> //printf
                    #include <stdlib.h> //exit
                    #include <sys/types.h>
                    #include <sys/socket.h> //socket
                    #include <netinet/in.h> //sockaddr_in
                    #include <arpa/inet.h> //htons inet_addr
                    #include <unistd.h> //close
                    #include <string.h>

                    int main(int argc, char const *argv[])
                    {
                        if(argc < 3)
                        {
                            fprintf(stderr, "Usage: %s <ip> <port>\n", argv[0]);
                            exit(1);
                        }

                        int sockfd; //文件描述符
                        struct sockaddr_in broadcataddr;
                        socklen_t addrlen = sizeof(broadcataddr);

                        //第一步：创建套接字
                        if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
                        {
                            perror("fail to socket");
                            exit(1);
                        }

                        //第二步：填充广播信息结构体
                        broadcataddr.sin_family = AF_INET;
                        broadcataddr.sin_addr.s_addr = inet_addr(argv[1]); //192.168.3.255 255.255.255.255
                        broadcataddr.sin_port = htons(atoi(argv[2]));

                        //第三步：将套接字与广播信息结构体绑定
                        if(bind(sockfd, (struct sockaddr *)&broadcataddr, addrlen) < 0)
                        {
                            perror("fail to bind");
                            exit(1);
                        }

                        //第四步：进行通信
                        char text[32] = "";
                        struct sockaddr_in sendaddr;

                        while(1)
                        {
                            if(recvfrom(sockfd, text, sizeof(text), 0, (struct sockaddr *)&sendaddr, &addrlen) < 0)
                            {
                                perror("fail to recvfrom");
                                exit(1);
                            }

                            printf("[%s - %d]: %s\n", inet_ntoa(sendaddr.sin_addr), ntohs(sendaddr.sin_port), text);
                        }

                        return 0;
                    }

                执行结果：
                    qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/3_tftp_broadcast_groupcast$ ./recv 192.168.177.255 9999
                    [192.168.177.128 - 58273]: nihao
                    [192.168.177.128 - 58273]: hello


                分析：
                    在广播时，发送者和接收者的IP地址都不是.255。
                        发送者只是将数据发送到目标地址（广播地址），所以终端传.255是传给结构体用作发送时的目标地址
                        而接收者：在 UDP 广播通信中，当发送者向广播地址（如255.255.255.255）发送数据报时，网络中的设备需要一种机制来接收这些广播消息。接收者绑定广播地址是为了能够监听发往该广播地址的 UDP 数据包
                            接受者的地址不是广播地址，接收者本身有自己独立的 IP 地址，这个地址用于在网络中唯一标识接收者自身。例如，在一个子网192.168.1.0/24中，接收者的 IP 地址可能是192.168.1.10之类的具体地址。
                            它绑定广播地址只是为了能够接收广播消息，而不是其自身的标识地址变成广播地址。
                            广播地址是一种特殊的网络地址，用于向网络中的所有主机发送消息。接收者绑定广播地址类似于订阅广播频道，
                            它本身还是有自己的 “家”（自身 IP 地址），这个 “家” 地址用于正常的网络通信和标识。





    3.5 UDP多播
        3.5.1 多播的概念
            3.5.1.1 多播概述
                多播：
                    数据的收发仅仅在同一分组中进行，所以多播又称之为组播
                多播的特点：
                    1、多播地址标示一组接口
                    2、多播可以用于广域网使用
                    3、在IPv4中，多播是可选的

                    类型      IPv4        IPv6
                    单播       ✔          ✔
                    多播      可选         ✔
                    广播       ✔          X
                    任播   ✔，但未广泛用   ✔


            3.5.1.2 多播地址(MAC地址）：
                    IPv4的 D 类地址是 多播地址
                    十进制：224.0.0.1 ~ 239.255.255.254
                    十六进制：E0.00.00.01 ~ EF.FF.FF.FE
                    多播地址向以太网MAC地址的映射

                    详细见WPS图:

                                               <——————  28 位组ID   ——————>
                            IPv4的D类地址   | E |   ||      |       |       |
                                                < - >
                                            忽略的5位         底序23位
                IPV4以太网多播地址 | 01 | 00 |   5e  ||      |       |       |
                                               中间这一位为0

               对于多播地址的问题：也就是MAC地址的问题，IPv4以太网多播地址（MAC地址），一共占6个字节24位。
                                多播地址的构成：取当前主机的（MAC地址）前3个字节，后3个字节是由多播的IP地址来构成，但是多播的IP地址一个只有4个字节，
                                              所以只取后3个字节，并且中间这一位，即倒数第24位 为0。所以只会IPv4 D类地址的底序23位。


        3.5.2 多播工作过程
            比起广播，多播具有可控性，只有加入多播组的接收者才可以接收数据，否则接收不到

            发广播和多播是有本质区别的：
                    广播：发送者必须允许发送广播才可以。广播的接收方：只有发送广播信息，当前网络下的所有主机都可以接收到
                    多播：不需要被允许。多播直接发送数据即可，不需要加入多播或允许多播。但接收方比较特别：但多播不同于广播，只有加入了多播组的接收者才可以接收数据，如果没有加入多播组，是接受不到数据的。所以多播相较于广播形式更好一点，他只会给加入了多播组的接收者发送消息。

            发送者给多播地址（Dst:224.0.1.1/7433）发送数据,经UDP传输层、IPv4（网络层）和数据链路层最终构成 1帧数据。

                        这一帧数据： | 以太网头部 | IPv4头部 | UDP头部 | UDP数据 |
                    DstMAC=01:00:5e:00:01:01 帧类型=0800       DstPort=7433
                                        DstIP=224.0.1.1 协议=UDP
            多播工作流程：
                    首先以太网头部（MAC地址）是由  当前进程所在系统的MAC地址的前3个字节 + 0 + 多播地址的后23位 构成的目的MAC地址。
                    IP地址就是多播IP地址。端口号自设定。

                    对于接收者，在链路层会先看是否事先加入了多播组，对比相应的MAC地址。如果链路层是一样的，则再对比网络层。
                    注意：链路层有一个 不完备硬件过滤：指的就是 补0的那一位， 若那一位为1则变为0，为0就还是0.所以 224.128.1.1 与 224.0.1.1是类似的（1000 0000 与 0000 0000  ）。所以不一定能完全确定是否加入了多播组。只有到了IPv4层完备软件过滤才能确定。
                              到了IPv4层时是完备过滤：加入了多播组就正常往上走，没加入就过滤。

        3.3 多播流程：
            发送者：
                1.创建套接字socket()
                2.向多播地址发送数据sendto()

            接收者：
                1.创建套接字socket()
                2.设置为加入多播组：setsockopt()
                3.将套接字与多播信息结构体绑定 bind（）
                4.接收数据。

        3.5.3 多播地址结构体：
            在 IPv4 因特网域(AF_INET)中，多播地址结构体用如下结构体 ip_mreq 表示

                struct in_addr
                {
                    in addr_t s_addr;
                }
                struct ip_mreq
                {
                    struct in_addr imr_multiaddr;//多播组IP    例：224.0.0.1
                    struct in_addr imr_interface;//将要哪一个主机添加到多播组的IP 当前本地的IP地址 例；使用宏：INADDR_ANY 表示你自己的主机地址。
                };

        3.5.4 多播套接口选项
            int setsockopt(int sockfd, int level,int optname,const void *optval, socklen_t optlen);
            成功执行返回 0，否则返回-1
                socket:文件描述符
                level:协议层次
                    IPPROTO_IP（不再是SOL_SOCKET） IP层
                optname: 选项名称
                    IP_ADD_MEMBERSHIP   加入多播组
                    IP_DROP_MEMBERSHIP  离开多播组
                optval类型：不再设为0（结构体含有：1.多播地址2.添加哪一个主机到多播组）
                    ip_mreq{}
                    ip_mreq{}
                option_len:option_value的长度。
                返回值：
                    成功 0
                    失败 -1

        3.5.5 加入多播组示例
            char group[INET_ADDRSTRLEN] = "224.0.1.1";

            //定义一个多播组地址
            struct ip_mreq mreq;

            //添加一个多播组IP
            mreq.imr_multiaddr.s_addr = inet_addr(group);

            //添加一个将要添加到多播组的IP
            mreq.imr_interface.s_addr = htonl(INADDR_ANY);

            setsockopt(sockfd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&mreq,sizeof(mreq));

    发送者：
                #include <stdio.h> //printf
                #include <stdlib.h> //exit
                #include <sys/types.h>
                #include <sys/socket.h> //socket
                #include <netinet/in.h> //sockaddr_in
                #include <arpa/inet.h> //htons inet_addr
                #include <unistd.h> //close
                #include <string.h>

                int main(int argc, char const *argv[])
                {
                    if(argc < 3)
                    {
                        fprintf(stderr, "Usage: %s <ip> <port>\n", argv[0]);
                        exit(1);
                    }

                    int sockfd; //文件描述符
                    struct sockaddr_in groupcastaddr; //服务器网络信息结构体
                    socklen_t addrlen = sizeof(groupcastaddr);

                    //第一步：创建套接字
                    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
                    {
                        perror("fail to socket");
                        exit(1);
                    }

                    //第二步：填充组播信息结构体
                    groupcastaddr.sin_family = AF_INET;
                    groupcastaddr.sin_addr.s_addr = inet_addr(argv[1]); //224.x.x.x - 239.x.x.x
                    groupcastaddr.sin_port = htons(atoi(argv[2]));

                    //第三步：进行通信
                    char buf[128] = "";
                    while(1)
                    {
                        fgets(buf, sizeof(buf), stdin);
                        buf[strlen(buf) - 1] = '\0';   //"hello\n"-->"hello\0"

                        if(sendto(sockfd, buf, sizeof(buf), 0, (struct sockaddr *)&groupcastaddr, addrlen) < 0)
                        {
                            perror("fail to sendto");
                            exit(1);
                        }
                    }

                    return 0;
                }


    执行结果：
        qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/3_tftp_broadcast_groupcast$ ./sendg 224.0.0.1 9999
        hello
        daosidj
        damlcac
        cdsv



    接收者：
                #include <stdio.h> //printf
                #include <stdlib.h> //exit
                #include <sys/types.h>
                #include <sys/socket.h> //socket
                #include <netinet/in.h> //sockaddr_in
                #include <arpa/inet.h> //htons inet_addr
                #include <unistd.h> //close
                #include <string.h>

                int main(int argc, char const *argv[])
                {
                    if(argc < 3)
                    {
                        fprintf(stderr, "Usage: %s <ip> <port>\n", argv[0]);
                        exit(1);
                    }

                    int sockfd; //文件描述符
                    struct sockaddr_in groupcastaddr;
                    socklen_t addrlen = sizeof(groupcastaddr);

                    //第一步：创建套接字
                    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
                    {
                        perror("fail to socket");
                        exit(1);
                    }

                    //第二步：设置为加入多播组
                    struct ip_mreq mreq;
                    mreq.imr_multiaddr.s_addr = inet_addr(argv[1]);
                    mreq.imr_interface.s_addr = INADDR_ANY;
                    if(setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0)
                    {
                        perror("fail to setsockopt");
                        exit(1);
                    }

                    //第三步：填充组播信息结构体
                    groupcastaddr.sin_family = AF_INET;
                    groupcastaddr.sin_addr.s_addr = inet_addr(argv[1]);  //224.x.x.x - 239.x.x.x
                    groupcastaddr.sin_port = htons(atoi(argv[2]));

                    //第四步：将套接字与广播信息结构体绑定
                    if(bind(sockfd, (struct sockaddr *)&groupcastaddr, addrlen) < 0)
                    {
                        perror("fail to bind");
                        exit(1);
                    }

                    //第五步：进行通信
                    char text[32] = "";
                    struct sockaddr_in sendaddr;

                    while(1)
                    {
                        if(recvfrom(sockfd, text, sizeof(text), 0, (struct sockaddr *)&sendaddr, &addrlen) < 0)
                        {
                            perror("fail to recvfrom");
                            exit(1);
                        }

                        printf("[%s - %d]: %s\n", inet_ntoa(sendaddr.sin_addr), ntohs(sendaddr.sin_port), text);
                    }

                    return 0;
                }



    执行结果：
        qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/3_tftp_broadcast_groupcast$ ./recvg 224.0.0.1 9999
        [192.168.177.128 - 50925]: hello
        [192.168.177.128 - 50925]: daosidj
        [192.168.177.128 - 50925]: damlcac
        [192.168.177.128 - 50925]: cdsv


*/

//第四章 TCP网络编程
/*
    4.1 TCP 介绍、编程流程
        TCP 回顾
            1、面向连接的流式协议;可靠、出错重传、且每收到一个数据都要给出相应的确认
            2、通信之前需要建立链接（）
            3、服务器被动链接，客户端是主动链接

        TCP 与 UDP 的差异:
                                TCP        UDP
                是否面向连接       ✔         X        面向连接（Connection-Oriented）‌是指在网络通信中，数据传输需要在发送方和接收方之间建立一个明确的连接，数据传输过程中保持该连接，直到数据传输完成后再释放连接。这种通信方式类似于电话系统，需要先拨号建立连接，通话结束后挂断。
                是否可靠          ✔         X
                是否广播，多播     X         ✔
                效率             低         高

            面向连接的主要特点
                1.‌连接建立‌：在数据传输开始之前，发送方和接收方需要建立一个明确的连接。这个过程通常包括一些握手操作，以确保双方都准备好进行数据传输。
                ‌2.数据传输‌：数据沿着已经建立的连接传输，保持连接的稳定性，确保数据的完整性和顺序。
                ‌3.连接释放‌：当数据传输完成后，连接会被释放，资源被回收。


        TCP/CS架构：
            见图(TCP与UDP流程对比)
            对于TCP服务器：
                1.创建套接字socket() ,其传参与UDP套接字不同。
                2.bind绑定，固定TCP服务器的信息。
                3.listen :将套接字设置为监听模式。
                4.accept:负责连接。阻塞等待客户端的连接
                5.如果有客户端连接上了，则可以开始读写数据了。read、write或者 使用  recv、send函数
                6.执行完毕后关闭close()。
            客户端：
                1.创建套接字
                2.使用connect发送客户端连接请求。给accept发数据的
                3.send （write）发送数据,recv（read）接收数据
                4.close关闭
TCP编程流程
    服务器：
        创建套接字 socket()
        将套接字与服务器网络信息结构体绑定 bind()
        将套接字设置为监听状态 listen()
        阻塞等待客户端的连接请求 accept()
        进行通信 recv()/send()
        关闭套接字 close()
    客户端：
        创建套接字 socket()
        发送客户端连接请求 connect()
        进行通信 send()/recv()
        关闭套接字 close()


    4.2 TCP 编程-socket
        4.2.1 TCP 套接字创建
            UDP 套接字创建回顾
                int sockfd;
                sockfd = socket (AF_INET,SOCK_DGRAM,0);
                if(sockfd < 0)
                {
                    perror("socket");
                    exit(1);
                }
            创建TCP套接字
                int sockfd;
                sockfd = socket (AF_INET,SOCK_STREAM,0);    //sock_DGRAM换成SOCK_STREAM
                if(sockfd < 0)
                {
                    perror("socket");
                    exit(1);
                }
        例：
                        #include <stdio.h>
                        #include <sys/types.h>
                        #include <sys/socket.h>
                        #include <stdlib.h>

                        int main(int argc, char const *argv[])
                        {
                            //通过socket函数创建一个TCP套接字
                            int sockfd;
                            if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
                            {
                                perror("fail to socket");
                                exit(1);
                            }

                            printf("sockfd = %d\n", sockfd);

                            return 0;
                        }


            做为客户端需要具备的条件
                1、知道“服务器”的 ip、port
                2、主动连接“服务器”
                3、需要用到的函数
                    socket—创建“主动 TCP 套接字”
                    connect—连接“服务器”
                    send—发送数据到“服务器”
                    recv—接受“服务器”的响应
                    close—关闭连接


    4.3 TCP 客户端-connect、send、recv
        4.3.1 connect 函数
        int connect(int sockfd,const struct sockaddr *addr,socklen_t len);
        功能：
            主动跟服务器建立链接,(发送连接请求)
        参数：
            sockfd：socket 套接字
            addr: 连接的服务器地址结构
            len： 地址结构体长度
        返回值：
            成功：0 失败：其他
        注意：
            1、connect 建立连接之后不会产生新的套接字
            2、连接成功后才可以开始传输 TCP 数据
            3、头文件：#include <sys/socket.h>


        4.3.2 send 函数
        头文件：
            #include <sys/socket.h>

        ssize_t send(int sockfd, const void* buf,size_t nbytes, int flags);
        功能：
            用于发送数据
        参数：
            sockfd： 已建立连接的套接字
            buf： 发送数据的地址
            nbytes: 发送缓数据的大小(以字节为单位)
            flags: 套接字标志(常为 0)
                        0：阻塞
                        MSG_DONTWAIT 非阻塞
        返回值：
            成功：发送的字节数
            失败 -1

        注意：
            不能用 TCP 协议发送 0 长度的数据包，UDP可以，TCP不行。


        4.3.3 recv 函数
        头文件：
            #include <sys/socket.h>
        ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);
        功能：
            用于接收网络数据
        参数：
            sockfd：套接字
            buf: 接收网络数据的缓冲区的地址
            nbytes: 接收缓冲区的大小(以字节为单位)
            flags: 套接字标志(常为 0)
                    0 阻塞
                    MSG_DONTWAIT 非阻塞
        返回值：
            成功：接收到字节数
            失败：-1
            如果发送端关闭文件描述符或者关闭进程，啧啧recv函数会返回0.


        4.3.4 客户端code代码
            使用windows下的网络调试助手设置为TCP服务器。
                协议类型为：TCP Server
                本地IP地址：windows使用ifconfig查询到的无线局域网IPv4的IP地址。
                端口号随意。
                连接对象：ALL Connections.

        例：
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include <unistd.h>
                        #include <sys/types.h>
                        #include <sys/socket.h>
                        #include <arpa/inet.h>
                        #include <netinet/in.h>
                        #include <string.h>

                        #define N 128

                        int main(int argc, char const *argv[])
                        {
                            if(argc < 3)
                            {
                                fprintf(stderr, "Usage: %s [ip] [port]\n", argv[0]);
                                exit(1);
                            }

                            //第一步：创建套接字
                            int sockfd;
                            if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
                            {
                                perror("fail to socket");
                                exit(1);
                            }

                            //printf("sockfd = %d\n", sockfd);

                            //第二步：发送客户端连接请求
                            struct sockaddr_in serveraddr;
                            socklen_t addrlen = sizeof(serveraddr);

                            serveraddr.sin_family = AF_INET;
                            serveraddr.sin_addr.s_addr = inet_addr(argv[1]); //s_addr是无符号32位的整型的数据所以需要使用inet_addr进行转化。
                            serveraddr.sin_port = htons(atoi(argv[2])); //atoi是将 数字型字符串 转换为 整型数据。如果这个字符串 没有其他非数字型，则可以使用的，但如果有非数字型的，就用不了。

                            if(connect(sockfd, (struct sockaddr *)&serveraddr, addrlen) == -1)
                            {
                                perror("fail to connect");
                                exit(1);
                            }

                            //第三步：进行通信
                            //发送数据

                            //单次接收和发送
                            char buf[N] = "";
                            fgets(buf, N, stdin);
                            buf[strlen(buf) - 1] = '\0';

                            if(send(sockfd, buf, N, 0) == -1)
                            {
                                perror("fail to send");
                                exit(1);
                            }

                            //接收数据
                            char text[N] = "";
                            if(recv(sockfd, text, N, 0) == -1)
                            {
                                perror("fail to recv");
                                exit(1);
                            }

                            printf("from server: %s\n", text);

                            //第四步：关闭套接字文件描述符
                            close(sockfd);

                            return 0;
                        }





    4.4 TCP服务器 bind、listen、accept
        4.4.1 做为 TCP 服务器需要具备的条件
            1、具备一个可以确知的地址
            2、让操作系统知道是一个服务器，而不是客户端
            3、等待连接的到来
            对于面向连接的 TCP 协议来说，连接的建立 才真正意味着数据通信的开始

        4.4.2 bind示例：bind 函数：
        #include <sys/types.h>
        #include <sys/socket.h>
        int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
        功能：
            将套接字与网络信息结构体绑定
        参数：
            sockfd：文件描述符，socket的返回值
            addr：网络信息结构体
                通用结构体（一般不用）
                    struct sockaddr
                网络信息结构体 sockaddr_in
                    #include <netinet/in.h>
                    struct sockaddr_in
            addrlen：addr的长度
        返回值：
            成功：0
            失败：‐1

           示例：
                int err_log = 0;
                unsigned short port = 8000;
                struct sockaddr_in_my_addr;

                bzero(&my_addr,sizeof(my_addr));
                my_addr.sin_family = AF_INET;
                my_addr.sin_port = htons(port);
                my_addr.sin_addr.s_addr = htonl(INADDR_ANY);

                err_log= bind(sockfd,(struet sockaddr*)&my_addr,sizeof(my_addr))
                if( err_log != 0)
                {
                    perror("binding");
                    close(sockfd):
                    exit(-1);
                }
        4.4.3 listen函数
            头文件：
                #include <sys/socket.h>

            int listen(int sockfd, int backlog);
            功能：
                将套接字由主动修改为被动
                使操作系统为该套接字设置一个连接队列，用来记录所有连接到该套接字的连接
            参数：
                sockfd： socket 监听套接字
                backlog：（同时）连接队列的长度
            返回值：
                成功：返回 0
                失败：其他

        4.4.4 accept 函数
        头文件：
            #include <sys/socket.h>
        int accept(int sockfd,struct sockaddr *cliaddr, socklen_t *addrlen);
        功能：
            从已连接队列中取出一个已经建立的连接，如果没有任何连接可用，则进入睡眠等待(阻塞)
        参数：
            sockfd： socket 监听套接字
            cliaddr: 用于存放客户端套接字地址结构
            addrlen：套接字地址结构体长度的地址
      * 返回值：
            已连接套接字很重要，详细原理见4-4.10accept函数课程。
            成功：新的文件描述符（只要有客户端连接，就会产生新的文件描述符，这个新的文件描述符专门与指定的客户端进行通信的）
            失败 -1.

        大致原理：对于TCP服务器,由于发送使用的是send函数，而非sendto，所以参数里面只有文件描述符，，而没有目标IP及端口，send函数只认文件描述符。
        那么就存在一个问题：当有多个客户端的时候，服务器如何指定发给谁。
                => 1.服务器端 创建套接字时的fd （socket的返回值）只起标识作用，不在通信过程中起作用
                   2.只要有一个客户端(客户端1)与服务器端连接，那么服务器的accept函数就会再重新产生一个新的文件描述符 fd1 ,客户端2与服务器连接就产生文件描述符 fd2。用于标识一块空间。
                    那么实际上是：fd1 在于客户端1 建立连接。 fd2 与客户端2 建立连接进行通信。所以客户端1发hello之后，给的并不是服务器，实质是给 fd1。所以服务器端原本socket创建的套接字只是起连接作用。
                    所以fd1与客户端绑定之后，使用 fd1 发的任何数据 都只会发给客户端1,同理 fd2 与客户端2 绑定之后，使用 fd2 发的任何数据 都只会发给客户端2。
                  * 所以执行完accept之后，客户端想要和服务器通信，那么调用send和recv时，服务器端应该用accept的返回值（fd1、fd2...），而不是socket的返回值（只起到标识作用）
                    所以在accept之前，包括调用accept时的传参都是用的socket的返回值。但 在accept之后，也就是通信的过程中使用的都是accept的返回值。
        注意：
            返回的是一个已连接套接字，这个套接字代表当前这个连接


        4.4.5 TCP服务器例子：
            服务器：
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include <unistd.h>
                        #include <sys/types.h>
                        #include <sys/socket.h>
                        #include <arpa/inet.h>
                        #include <netinet/in.h>
                        #include <string.h>

                        #define N 128

                        int main(int argc, char const *argv[])
                        {
                            if(argc < 3)
                            {
                                fprintf(stderr, "Usage: %s [ip] [port]\n", argv[0]);
                                exit(1);
                            }

                            //第一步：创建套接字
                            int sockfd;
                            if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
                            {
                                perror("fail to socket");
                                exit(1);
                            }

                            //第二步：将套接字与服务器网络信息结构体绑定
                            struct sockaddr_in serveraddr;
                            socklen_t addrlen = sizeof(serveraddr);

                            serveraddr.sin_family = AF_INET;
                            serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                            serveraddr.sin_port = htons(atoi(argv[2]));

                            if(bind(sockfd, (struct sockaddr *)&serveraddr, addrlen) == -1)
                            {
                                perror("fail to bind");
                                exit(1);
                            }

                            //第三步：将套接字设置为被动监听状态
                            if(listen(sockfd, 10) == -1)
                            {
                                perror("fail to listen");
                                exit(1);
                            }

                            //第四步：阻塞等待客户端的链接请求
                            int acceptfd;
                            struct sockaddr_in clientaddr;
                            if((acceptfd = accept(sockfd, (struct sockaddr *)&clientaddr, &addrlen)) == -1)
                            {
                                perror("fail to accept");
                                exit(1);
                            }

                            //打印连接的客户端的信息
                            printf("ip:%s, port:%d\n", inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));

                            //第五步：进行通信
                            //tcp服务器与客户端通信时，需要使用accept函数的返回值
                            char buf[N] = "";
                            if(recv(acceptfd, buf, N, 0) == -1)
                            {
                                perror("fail to recv");
                            }

                            printf("from client: %s\n", buf);

                            strcat(buf, " *_*");
                            if(send(acceptfd, buf, N, 0) == -1)
                            {
                                perror("fail to send");
                                exit(1);
                            }

                            //关闭套接字文件描述符
                            close(acceptfd);
                            close(sockfd);

                            return 0;
                        }

                客户端：
                            #include <stdio.h>
                            #include <stdlib.h>
                            #include <unistd.h>
                            #include <sys/types.h>
                            #include <sys/socket.h>
                            #include <arpa/inet.h>
                            #include <netinet/in.h>
                            #include <string.h>

                            #define N 128

                            int main(int argc, char const *argv[])
                            {
                                if(argc < 3)
                                {
                                    fprintf(stderr, "Usage: %s [ip] [port]\n", argv[0]);
                                    exit(1);
                                }

                                //第一步：创建套接字
                                int sockfd;
                                if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
                                {
                                    perror("fail to socket");
                                    exit(1);
                                }

                                //printf("sockfd = %d\n", sockfd);

                                //第二步：发送客户端连接请求
                                struct sockaddr_in serveraddr;
                                socklen_t addrlen = sizeof(serveraddr);

                                serveraddr.sin_family = AF_INET;
                                serveraddr.sin_addr.s_addr = inet_addr(argv[1]); //s_addr是无符号32位的整型的数据所以需要使用inet_addr进行转化。
                                serveraddr.sin_port = htons(atoi(argv[2])); //atoi是将 数字型字符串 转换为 整型数据。如果这个字符串 没有其他非数字型，则可以使用的，但如果有非数字型的，就用不了。

                                if(connect(sockfd, (struct sockaddr *)&serveraddr, addrlen) == -1)
                                {
                                    perror("fail to connect");
                                    exit(1);
                                }

                                //第三步：进行通信
                                //发送数据
                            #if 0
                                //循环一直发送和接收，注意：需要把send和recv改成非阻塞：MSG_DONTWAIT
                                char buf[N] = "";
                                char text[N] = "";
                                while(1)
                                {
                                    fgets(buf, N, stdin);
                                    buf[strlen(buf) - 1] = '\0';

                                    if(send(sockfd, buf, N, MSG_DONTWAIT) == -1)
                                    {
                                        perror("fail to send");
                                        exit(1);
                                    }

                                    //接收数据
                                    if(recv(sockfd, text, N, MSG_DONTWAIT) == -1)
                                    {
                                        perror("fail to recv");
                                        exit(1);
                                    }

                                    printf("from server: %s\n", text);
                                }
                            #endif

                            #if 1
                                //单次接收和发送
                                char buf[N] = "";
                                fgets(buf, N, stdin);
                                buf[strlen(buf) - 1] = '\0';

                                if(send(sockfd, buf, N, 0) == -1)
                                {
                                    perror("fail to send");
                                    exit(1);
                                }

                                //接收数据
                                char text[N] = "";
                                if(recv(sockfd, text, N, 0) == -1)
                                {
                                    perror("fail to recv");
                                    exit(1);
                                }

                                printf("from server: %s\n", text);
                            #endif
                                //第四步：关闭套接字文件描述符
                                close(sockfd);

                                return 0;
                            }



    4.5 TCP 编程-close、三次握手、四次挥手
        4.5.1 close 关闭套接字
            1、使用 close 函数即可关闭套接字
                关闭一个代表已连接套接字将导致另一端接收到一个 0 长度的数据包
            2、做服务器时
                1>关闭监听套接字将导致服务器无法接收新的连接，但不会影响已经建立的连接
                2>关闭 accept 返回的已连接套接字将导致它所代表的连接被关闭，但不会影响服务器的监听
            3、做客户端时
                关闭连接就是关闭连接，不意味着其他

        4.5.2 三次握手
                客户端                                 服务器

                connect(阻塞) ————SYN J
                                               ————>accert(阻塞)
                                 SYN K(J+1)————
                connect返回<————
                             ————  ACK  (k+1)
                                            ——————>accept返回值

                                三次握手


        4.5.3 四次挥手

                close(主动关闭) ————FIN M
                                               ————>（被动关闭）read返回0
                                   ACK(M+1)————
                connect返回<————   FIN N  ————
                           <————
                            ——————ACK (N+1)
                                               ————>accept返回值

                                四次挥手



    4.6 TCP并发服务器
        在UDP编程的时候，UDP可以同时运行多个客户端，而且每个客户端都可以同服务器进行通信。一个服务器可以控制多个客户端与之交流————并发

        而TCP服务器原本并不是一个并发服务器，它同一时间只能与一个客户端进行通信。
        例如：
                客户端：
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include <unistd.h>
                        #include <sys/types.h>
                        #include <sys/socket.h>
                        #include <arpa/inet.h>
                        #include <netinet/in.h>
                        #include <string.h>

                        #define N 128
                        #define ERR_LOG(errmsg) do{\
                                                    perror(errmsg);\
                                                    exit(1);\
                                                }while(0)

                        int main(int argc, char const *argv[])
                        {
                            if(argc < 3)
                            {
                                fprintf(stderr, "Usage: %s <server_ip> <server_port>\n", argv[0]);
                                exit(1);
                            }

                            int sockfd;
                            struct sockaddr_in serveraddr;

                            //第一步：创建套接字
                            if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
                            {
                                ERR_LOG("fail to socket");
                            }

                            //第二步：填充服务器网络信息结构体
                            serveraddr.sin_family = AF_INET;
                            serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                            serveraddr.sin_port = htons(atoi(argv[2]));

                            //第三步：发送客户端连接请求
                            if(connect(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0)
                            {
                                ERR_LOG("fail to connect");
                            }

                            //第四步：进行通信
                            char buf[N] = "";
                            while(1)
                            {
                                fgets(buf, N, stdin);
                                buf[strlen(buf) - 1] = '\0';

                                if(send(sockfd, buf, N, 0) < 0)
                                {
                                    ERR_LOG("fail to send");
                                }

                                if(strncmp(buf, "quit", 4) == 0)
                                {
                                    exit(0);
                                }

                                if(recv(sockfd, buf, N, 0) < 0)
                                {
                                    ERR_LOG("fail to recv");
                                }

                                printf("from server: %s\n", buf);
                            }

                            //第四步：关闭套接字
                            close(sockfd);

                            return 0;
                        }


                服务器：
                        //tcp服务器的实现
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include <unistd.h>
                        #include <sys/types.h>
                        #include <sys/socket.h>
                        #include <arpa/inet.h>
                        #include <netinet/in.h>
                        #include <string.h>
                        #include <signal.h>

                        #define N 128
                        #define ERR_LOG(errmsg) do{\
                                                    perror(errmsg);\
                                                    exit(1);\
                                                }while(0)

                        int main(int argc, char const *argv[])
                        {
                            if(argc < 3)
                            {
                                fprintf(stderr, "Usage: %s <server_ip> <server_port>\n", argv[0]);
                                exit(1);
                            }

                            int sockfd, acceptfd;
                            struct sockaddr_in serveraddr, clientaddr;
                            socklen_t addrlen = sizeof(serveraddr);

                            //第一步：创建套接字
                            if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
                            {
                                ERR_LOG("fail to socket");
                            }

                            //将套接字设置为允许重复使用本机地址或者设置为端口复用
                            int on = 1;
                            if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
                            {
                                ERR_LOG("fail to setsockopt");
                            }

                            //第二步：填充服务器网络信息结构体
                            serveraddr.sin_family = AF_INET;
                            serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                            serveraddr.sin_port = htons(atoi(argv[2]));

                            //第三步：将套接字与服务器网络信息结构体绑定
                            if(bind(sockfd, (struct sockaddr *)&serveraddr, addrlen) < 0)
                            {
                                ERR_LOG("fail to bind");
                            }

                            //第四步：将套接字设置为被动监听状态
                            if(listen(sockfd, 5) < 0)
                            {
                                ERR_LOG("fail to listen");
                            }

                            //第五步：阻塞等待客户端的连接请求
                            if((acceptfd = accept(sockfd, (struct sockaddr *)&clientaddr, &addrlen)) < 0)
                            {
                                ERR_LOG("fail to accept");
                            }

                            //打印客户端的信息
                            printf("%s -- %d\n", inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));

                            //第六步：进行通信
                            char buf[N] = "";
                            ssize_t bytes;
                            while (1)
                            {
                                //注意：tcp中服务器与客户端通信时，一定要用accept函数的返回值来通信
                                if((bytes = recv(acceptfd, buf, N, 0)) < 0)
                                {
                                    ERR_LOG("fail to recv");
                                }
                                else if(bytes == 0)
                                {
                                    printf("The client quited\n");
                                    exit(1);
                                }

                                if(strncmp(buf, "quit", 4) == 0)
                                {
                                    exit(0);
                                }

                                printf("from client: %s\n", buf);

                                strcat(buf, " ^_^");
                                if(send(acceptfd, buf, N, 0) < 0)
                                {
                                    ERR_LOG("fail to send");
                                }
                            }

                            //第七步：关闭套接字
                            close(acceptfd);
                            close(sockfd);

                            return 0;
                        }

                  之所以不是并发：accept和  recv都是阻塞函数，只有执行完accept之后才能执行recv。而且加了while循环。也就意味着，只要有客户端与服务器连接之后，代码就没有办法再回到accept位置继续向下运行
                        这就导致TCP没办法实现并发：有两个阻塞函数，并且这两个阻塞函数必须按顺序执行。而UDP只有一个阻塞函数recvfrokm 在服务器端，所以它可以实现并发。

                    总结：
                        TCP不能实现并发的原因：
                            由于TCP服务器端有两个读阻塞函数，accept和recv，两个函数需要先后运行，所以导致运
                            行一个函数的时候另一个函数无法执行，所以无法保证一边连接客户端，一边与其他客户端
                            通信
                        如何实现TCP并发服务器：
                            使用多进程实现TCP并发服务器
                            使用多线程实现TCP并发服务器

        4.6.1 多进程实现并发
                一个进程实现accept
                另一个进程实现recv，保证两个同时运行。
                （客户端不需要修改，只需要修改服务器）

                服务器流程：
                    int sockfd = socket();
                    bind()
                    listen();
                    while(1)
                    {
                        acceptfd = accept()
                        pid = fork();
                        if(pid > 0)
                        {
                            //由于父进程什么都不执行，并且外面有while(1)循环，那么它执行完后，会在accept阻塞，直到又来一个客户端来连接，就再创建一个子进程。
                            //而子进程由于一直在执行子进程代码里面的while循环，所以一直在通信，不会有影响。
                        }
                        else if(pid == 0)
                        {
                            while(1)
                            {
                                recv()/send();
                            }
                        }
                    }
            案例：
            客户端04 ：
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include <unistd.h>
                        #include <sys/types.h>
                        #include <sys/socket.h>
                        #include <arpa/inet.h>
                        #include <netinet/in.h>
                        #include <string.h>

                        #define N 128
                        #define ERR_LOG(errmsg) do{\
                                                    perror(errmsg);\
                                                    exit(1);\
                                                }while(0)

                        int main(int argc, char const *argv[])
                        {
                            if(argc < 3)
                            {
                                fprintf(stderr, "Usage: %s <server_ip> <server_port>\n", argv[0]);
                                exit(1);
                            }

                            int sockfd;
                            struct sockaddr_in serveraddr;

                            //第一步：创建套接字
                            if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
                            {
                                ERR_LOG("fail to socket");
                            }

                            //第二步：填充服务器网络信息结构体
                            serveraddr.sin_family = AF_INET;
                            serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                            serveraddr.sin_port = htons(atoi(argv[2]));

                            //第三步：发送客户端连接请求
                            if(connect(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0)
                            {
                                ERR_LOG("fail to connect");
                            }

                            //第四步：进行通信
                            char buf[N] = "";
                            while(1)
                            {
                                fgets(buf, N, stdin);
                                buf[strlen(buf) - 1] = '\0';

                                if(send(sockfd, buf, N, 0) < 0)
                                {
                                    ERR_LOG("fail to send");
                                }

                                if(strncmp(buf, "quit", 4) == 0)
                                {
                                    exit(0);
                                }

                                if(recv(sockfd, buf, N, 0) < 0)
                                {
                                    ERR_LOG("fail to recv");
                                }

                                printf("from server: %s\n", buf);
                            }

                            //第四步：关闭套接字
                            close(sockfd);

                            return 0;
                        }

                服务器06：
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include <unistd.h>
                        #include <sys/types.h>
                        #include <sys/socket.h>
                        #include <arpa/inet.h>
                        #include <netinet/in.h>
                        #include <string.h>
                        #include <signal.h>
                        #include <sys/wait.h>
                        #include <signal.h>

                        //使用多进程实现TCP并发服务器

                        #define N 128
                        #define ERR_LOG(errmsg) do{\
                                                    perror(errmsg);\
                                                    exit(1);\
                                                }while(0)

                        void handler(int sig)
                        {
                            wait(NULL);
                            //1.SIGCHLD信号捕捉，父进程使用signal函数注册SIGCHLD的处理函数，当子进程终止就会发送该信号给父进程，父进程在信号处理函数中调用wait函数来处理子进程的终止状态。
                            //wait函数作用：父进程通过该系统调用等待子进程的终止，并获取子进程的终止状态，完全清除子进程的状态信息。
                        }

                        int main(int argc, char const *argv[])
                        {
                            if(argc < 3)
                            {
                                fprintf(stderr, "Usage: %s <server_ip> <server_port>\n", argv[0]);
                                exit(1);
                            }

                            int sockfd, acceptfd;
                            struct sockaddr_in serveraddr, clientaddr;
                            socklen_t addrlen = sizeof(serveraddr);

                            //第一步：创建套接字
                            if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
                            {
                                ERR_LOG("fail to socket");
                            }

                            //将套接字设置为允许重复使用本机地址或者为设置为端口复用
                            int on = 1;
                            if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
                            {
                                ERR_LOG("fail to setsockopt");
                            }

                            //第二步：填充服务器网络信息结构体
                            serveraddr.sin_family = AF_INET;
                            serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                            serveraddr.sin_port = htons(atoi(argv[2]));

                            //第三步：将套接字与服务器网络信息结构体绑定
                            if(bind(sockfd, (struct sockaddr *)&serveraddr, addrlen) < 0)
                            {
                                ERR_LOG("fail to bind");
                            }

                            //第四步：将套接字设置为被动监听状态
                            if(listen(sockfd, 5) < 0)
                            {
                                ERR_LOG("fail to listen");
                            }

                            //使用信号，异步通信的方式处理僵尸进程
                            signal(SIGCHLD, handler);   //当子进程的状态改变，也就意味着如果子进程退出那么就会立刻产生 SIGCHLD 的信号，然后 在信号处理函数处理wait

                            while(1)
                            {
                                //第五步：阻塞等待客户端的连接请求
                                if((acceptfd = accept(sockfd, (struct sockaddr *)&clientaddr, &addrlen)) < 0)
                                {
                                    ERR_LOG("fail to accept");
                                }

                                //打印客户端的信息
                                printf("%s -- %d\n", inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));

                                //使用fork函数创建子进程，父进程继续负责连接，子进程负责与客户端通信
                                pid_t pid;
                                if((pid = fork()) < 0)
                                {
                                    ERR_LOG("fail to fork");
                                }
                                else if(pid > 0) //父进程负责执行accept，所以if语句结束后继续在accept函数的位置阻塞
                                {
                                }
                                else //子进程负责跟指定的客户端通信
                                {
                                    char buf[N] = "";
                                    ssize_t bytes;
                                    while (1)
                                    {
                                        if((bytes = recv(acceptfd, buf, N, 0)) < 0)
                                        {
                                            ERR_LOG("fail to recv");
                                        }
                                        else if(bytes == 0)
                                        {
                                            printf("The client quited\n");
                                            exit(0);
                                        }

                                        if(strncmp(buf, "quit", 4) == 0)
                                        {
                                            exit(0);
                                        }

                                        printf("from client: %s\n", buf);

                                        strcat(buf, " ^_^");
                                        if(send(acceptfd, buf, N, 0) < 0)
                                        {
                                            ERR_LOG("fail to send");
                                        }
                                    }
                                }
                            }

                            return 0;
                        }



        4.6.2 多线程实现并发
                void *thread_fun(void * arg)
                {
                    //因为创建的子线程，所以通信是在子线程的处理函数的while里面
                    while(1)
                    {
                        recv()/send();
                    }
                }

                int sockfd = socket();
                bind()
                listen();
                while(1)
                {
                    acceptfd = accept()
                    //只要有一个客户端连接上，就创建一个子线程与之通信。
                    pthread_create(&thread,NULL，thread_fun,&msg)//1.线程ID 2.线程属性 NULL 3. 线程处理函数 4.给子线程函数的传参
                    pthread_detach(); //将子线程设置为分离态。//保证当前整个原本的主控线程能继续运行，并且保证子线程退出之后，资源还能被回收。
                }
        例：
        客户端代码同多进程一致都为04代码。
        服务器：
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <unistd.h>
                    #include <sys/types.h>
                    #include <sys/socket.h>
                    #include <arpa/inet.h>
                    #include <netinet/in.h>
                    #include <string.h>
                    #include <signal.h>
                    #include <pthread.h>

                    #define N 128
                    #define ERR_LOG(errmsg) do{\
                                                perror(errmsg);\
                                                exit(1);\
                                            }while(0)

                    typedef struct{
                        struct sockaddr_in addr;
                        int acceptfd;
                    }MSG;

                    void *pthread_fun(void *arg)
                    {
                        char buf[N] = "";
                        ssize_t bytes;
                        MSG msg = *(MSG *)arg;
                        while (1)
                        {
                            if((bytes = recv(msg.acceptfd, buf, N, 0)) < 0)
                            {
                                ERR_LOG("fail to recv");
                            }
                            else if(bytes == 0)
                            {
                                printf("The client quited\n");
                                pthread_exit(NULL);
                            }

                            if(strncmp(buf, "quit", 4) == 0)
                            {
                                printf("The client quited\n");
                                pthread_exit(NULL);
                            }

                            printf("[%s - %d]: %s\n", inet_ntoa(msg.addr.sin_addr), ntohs(msg.addr.sin_port), buf);

                            strcat(buf, " ^_^");
                            if(send(msg.acceptfd, buf, N, 0) < 0)
                            {
                                ERR_LOG("fail to send");
                            }
                        }
                    }

                    int main(int argc, char const *argv[])
                    {
                        if(argc < 3)
                        {
                            fprintf(stderr, "Usage: %s <server_ip> <server_port>\n", argv[0]);
                            exit(1);
                        }

                        int sockfd, acceptfd;
                        struct sockaddr_in serveraddr, clientaddr;
                        socklen_t addrlen = sizeof(serveraddr);

                        //第一步：创建套接字
                        if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
                        {
                            ERR_LOG("fail to socket");
                        }

                        //将套接字设置为允许重复使用本机地址或者为设置为端口复用
                        int on = 1;
                        if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
                        {
                            ERR_LOG("fail to setsockopt");
                        }

                        //第二步：填充服务器网络信息结构体
                        serveraddr.sin_family = AF_INET;
                        serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                        serveraddr.sin_port = htons(atoi(argv[2]));

                        //第三步：将套接字与服务器网络信息结构体绑定
                        if(bind(sockfd, (struct sockaddr *)&serveraddr, addrlen) < 0)
                        {
                            ERR_LOG("fail to bind");
                        }

                        //第四步：将套接字设置为被动监听状态
                        if(listen(sockfd, 5) < 0)
                        {
                            ERR_LOG("fail to listen");
                        }

                        while(1)
                        {
                            //第五步：阻塞等待客户端的连接请求
                            if((acceptfd = accept(sockfd, (struct sockaddr *)&clientaddr, &addrlen)) < 0)
                            {
                                ERR_LOG("fail to accept");
                            }

                            //打印客户端的信息
                            //printf("%s -- %d\n", inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));

                            //创建子线程与客户端进行通信
                            MSG msg;
                            msg.addr = clientaddr;
                            msg.acceptfd = acceptfd;
                            pthread_t thread;
                            if(pthread_create(&thread, NULL, pthread_fun, &msg) != 0)
                            {
                                ERR_LOG("fail to pthread_create");
                            }

                            //将子线程设置为分离态：
                            pthread_detach(thread);
                        //     子线程设置为分离态的主要作用是减少系统开销和提高程序效率‌。
                        //     当子线程被设置为分离态后，它结束时会自动释放所占用的资源，
                        //     无需其他线程调用pthread_join()等待其结束，
                        //     从而避免了主线程的阻塞，提高了程序的并发性和资源利用率‌
                        // }

                        return 0;
                    }




    4.7 Web服务器介绍
        4.7.1 web服务器简介
            Web 服务器又称 WWW 服务器、网站服务器等
            特点
                使用 HTTP 协议（超文本协议）与客户机浏览器进行信息交流
                不仅能存储信息，还能在用户通过 web 浏览器提供的信息的基础上运行脚本和程序
                该服务器需可安装在 UNIX、Linux 或 Windows 等操作系统上
                著名的服务器有 Apache、Tomcat、 IIS 等

        4.7.2 HTTP 协议：

            （在将UDP的时候，有一个TFTP协议，简单 文件 传输协议，该协议主要是基于UDP的应用层协议。
            而此时的HTTP是基于TCP的应用层协议）

            Webserver—HTTP 协议（超文本协议）
            概念
                一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议
            特点
                1、支持 C/S 架构（HTTP就是服务器端，通过浏览器就相当于是客户端，就可以去访问服务器端的一些内容。）
                2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径 ，常用方法:GET（明文）、POST（密文）。
                3、无连接：限制每次连接只处理一个请求
                4、无状态：即如果后续处理需要前面的信息，它必须重传，这样可能导致每次连接传送的数据量会增大（采用多线程来处理，采用多线程实现并发）

        4.7.3 Webserver 通信过程
            就是TCP的整个通信，也就意味着，咱们了解的Web服务器就是通过HTTP协议将原本保存的网页读出来，显示到浏览器当中。只不过规定了相应的格式而已。


                                                Web服务器
                                                socket()
                                                bind()
                                                listen()
                                                    |
                                                accept()
              ——————————                            |
              |         |                           |
              |         |                           |
              | 客户端   |<——连接建立（TCP三次握手）——>阻塞直至
              |（浏览器）|                         客户端连接
              |         |                           |<——————————————
              |         |   ————请求——>           read()             |
              |         |                           |               |
              |         |                           |（处理请求）     |
              |         |   <—————应答——          write()            |
              |         |                           |————————————————
              |         |   <———文件结束通知——      close()
              |         |
              ———————————


    4.8 Web 编程开发
        网页浏览 （使用GET方式）
        客户端浏览器请求
            我们一般都是输的网址，就本质而言，网址一般就是IP地址

            输入格式：http://10.0.31.110:8000/index.html
                    例如要在Ubuntu下跑：
                        http://192.168.177.128:9999/想要访问的网页

                       如： http://192.168.177.128:9999/about.html
            这相当于是：web服务器的ip地址是192.168.177.128，端口号是9999，要访问的网页是about.html。


        服务器收到的数据：
            对于：http://10.0.31.110:8000/index.html
            服务器收到：
                    GET/index.html HTTP/1.1
                    Accept:image/gif.image/jpeg, *//*   (这里两个*之间要少一个/)
                    Accept-Language:zh-cn
                    Connection:Keep-Alive
                    Host:localhost
                    Accept-Encoding:gzip,deflate

            如果GET后面的网页存在则访问，不存在则出错。

        服务器的应答格式
            服务器接收到浏览器发送的数据之后，需要判断GET/后面跟的网页是否存在，
            若存在则请求成功，发送指定的指令，并发送文件内容给浏览器，
            若不存在，则发送请求失败的指令。

            请求成功：
                HTTP/1.1 200 OK
                Server:Apache Tomcat/5.0.12     //服务器对应的版本
                Content-Type:text/html
                Content-Length:28
                <body>
                Hello HTTP!
                </body>

                "HTTP/1.1 200OK\r\n"
                "Content-Type:text/html\r\n"
                "\r\n"
                (重点是最后这句话)


            请求失败：
                HTTP/1.1 404 Not Fount
                Server:Apache Tomcat/5.0.12
                Content-Type:text/html
                Content-Length:40
                <HTML><BODY>File not fount</BODY></HTML>

                "HTIP/1.1 404 Not Found\r\n"
                "Content-Type:text/html\r\n"
                "\r\n"
                "<HTML><BODY>File not found</BODY><HTML>"
                (重点是最后这句话)



    案例：


                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <unistd.h>
                    #include <sys/types.h>
                    #include <sys/socket.h>
                    #include <arpa/inet.h>
                    #include <netinet/in.h>
                    #include <string.h>
                    #include <pthread.h>
                    #include <sys/stat.h>
                    #include <fcntl.h>
                    #include <errno.h>

                    #define N 1024
                    #define ERR_LOG(errmsg) do{\
                                                perror(errmsg);\
                                                printf("%s - %s - %d\n", __FILE__, __func__, __LINE__);\
                                                exit(1);\
                                            }while(0)

                    void *pthread_fun(void *arg)
                    {
                        int acceptfd = *(int *)arg;
                        char buf[N] = "";
                        char head[]="HTTP/1.1 200 OK\r\n"                   \
                                "Content-Type: text/html\r\n"       \
                                "\r\n";
                        char err[]= "HTTP/1.1 404 Not Found\r\n"        \
                            "Content-Type: text/html\r\n"       \
                            "\r\n"                              \
                            "<HTML><BODY>File not found</BODY></HTML>";

                        //接收浏览器通过http协议发送的数据包
                        if(recv(acceptfd, buf, N, 0) < 0)
                        {
                            ERR_LOG("fail to recv");
                        }

                        printf("*****************************\n\n");
                        printf("%s\n", buf);
                        // int i;
                        // for(i = 0; i < 200; i++)
                        // {
                        //     printf("[%c] - %d\n", buf[i], buf[i]);
                        // }
                        printf("\n*****************************\n");

                        //通过获取的数据包中得到浏览器要访问的网页文件名
                        //GET /about.html http/1.1
                        char filename[128] = "";
                        sscanf(buf, "GET /%s", filename);   //sscanf函数与空格结束，所以直接可以获取文件名

                        if(strncmp(filename, "HTTP/1.1", strlen("http/1.1")) == 0)
                        {
                            strcpy(filename, "about.html");
                        }
                        printf("filename = %s\n", filename);

                        char path[128] = "./sqlite/";
                        strcat(path, filename);

                        //通过解析出来的网页文件名，查找本地中有没有这个文件
                        int fd;
                        if((fd = open(path, O_RDONLY)) < 0)
                        {
                            //如果文件不存在，则发送不存在对应的指令
                            if(errno == ENOENT)
                            {
                                if(send(acceptfd, err, strlen(err), 0) < 0)
                                {
                                    ERR_LOG("fail to send");
                                }

                                close(acceptfd);
                                pthread_exit(NULL);
                            }
                            else
                            {
                                ERR_LOG("fail to open");
                            }
                        }

                        //如果文件存在，先发送指令告知浏览器
                        if(send(acceptfd, head, strlen(head), 0) < 0)
                        {
                            ERR_LOG("fail to send");
                        }

                        //读取网页文件中的内容并发送给浏览器
                        ssize_t bytes;
                        char text[1024] = "";
                        while((bytes = read(fd, text, 1024)) > 0)
                        {
                            if(send(acceptfd, text, bytes, 0) < 0)
                            {
                                ERR_LOG("fail to send");
                            }
                        }

                        pthread_exit(NULL);
                    }

                    int main(int argc, char const *argv[])
                    {
                        if(argc < 3)
                        {
                            fprintf(stderr, "Usage: %s <server_ip> <server_port>\n", argv[0]);
                            exit(1);
                        }

                        int sockfd, acceptfd;
                        struct sockaddr_in serveraddr, clientaddr;
                        socklen_t addrlen = sizeof(serveraddr);

                        //第一步：创建套接字
                        if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
                        {
                            ERR_LOG("fail to socket");
                        }

                        //将套接字设置为允许重复使用本机地址或者为设置为端口复用
                        int on = 1;
                        if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
                        {
                            ERR_LOG("fail to setsockopt");
                        }

                        //第二步：填充服务器网络信息结构体
                        serveraddr.sin_family = AF_INET;
                        serveraddr.sin_addr.s_addr = inet_addr(argv[1]);
                        serveraddr.sin_port = htons(atoi(argv[2]));

                        //第三步：将套接字与服务器网络信息结构体绑定
                        if(bind(sockfd, (struct sockaddr *)&serveraddr, addrlen) < 0)
                        {
                            ERR_LOG("fail to bind");
                        }

                        //第四步：将套接字设置为被动监听状态
                        if(listen(sockfd, 5) < 0)
                        {
                            ERR_LOG("fail to listen");
                        }

                        while(1)
                        {
                            //第五步：阻塞等待客户端的连接请求
                            if((acceptfd = accept(sockfd, (struct sockaddr *)&clientaddr, &addrlen)) < 0)
                            {
                                ERR_LOG("fail to accept");
                            }

                            //打印客户端的信息
                            printf("%s -- %d\n", inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));

                            //创建线程接收数据并处理数据
                            pthread_t thread;
                            if(pthread_create(&thread, NULL, pthread_fun, &acceptfd) != 0)
                            {
                                ERR_LOG("fail to pthread_create");
                            }
                            pthread_detach(thread);

                        }

                        return 0;
                    }
                    // gcc 08_webserver.c -lpthread
                    //./aout 192.168.177.128 9999

*/

//第五章：网络通信过程：
/*
    5.1 网络通信概述：

        通过对 TCP、UDP 的编程学习，能够完成对实际项目需求中网络功能的开发，为了提高程序的稳定性以及效
        率等等，通常会使用多线程、多进程开发；根据功能需求的不同，可以利用 C/S（客户端服务器模型）、B/S （浏览器服务器模式）模式进行开发
        作为嵌入式工程师，需要对整个网络通信的过程进行掌握，从一个整体的角度来开发出更加稳定、效率的网
        络程序
        想一想
        PC0 怎样才能够访问到 www.qfedu.com
            见图

        网络通信过程分析软件
        Packet Tracer 是由 Cisco 公司发布的一个辅助学习工具，提供了设计、配置、排除网络故障网络模拟环境
        可以直接使用拖曳方法建立网络拓扑，并可提供数据包在网络中行进的详细处理过程，观察网络实时运行情况

    5.2 通信过程（通过交换机实现同一网段的通信）
        5.2.1 交换机介绍
            网络交换机（又称“网络交换器”），是一个扩大网络的器材，可以把更多的计算机等网络设备连接到当前的网络中。
            具有性价比高、高度灵活、相对简单、易于实现等特点

            以太网技术已成为当今最重要的一种局域网组网技术，网络交换机也就成为了最普及的交换机
            (交换机可以通过网线连接多台主机，但如果连接之后，主机之间想要通信必须要保证这些主机之间是同一网段的，如果不是同一网段连接交换机之后也是没有办法进行通信的。)

        5.2.2 交换机功能
            1、转发过滤：
                    当一个数据帧的目的地址在 MAC 地址表中有映射时，它被转发到连接目的节点的端口而不是
                    所有端口（如该数据帧为广播/组播帧则转发至所有端口）
            2、学习功能：
                    以太网交换机了解 每一端口相连设备的 MAC 地址，并将地址同相应的端口映射起来存放在交换机缓存中的 MAC 地址表中。
                    （也就是说：交换机有一个 MAC 地址表，标明了每一台连接到交换机上的主机的MAC地址。那么当一台主机与另一台主机通信的时候，就可以在我的MAC地址表中找我的 目的MAC地址 ，
                    如果在我的交换机的MAC地址表有，则可以把数据直接发给他。）
            3、目前交换机还具备了一些新的功能，如对 VLAN（虚拟局域网）的支持、对链路汇聚的支持，甚至有的还具有防火墙的功能（防火墙：过滤一些信息用的，如：过滤一些IP地址、MAC地址、端口号等等。）

        5.2.3 通信过程（PC+switch）
            （我们知道：电脑一般最多只有一个网口，那么不借助交换机，就最多只能与一台电脑进行通信，但要实现多台主机进行通信就需要使用交换机）


            通过交换机可以组成一个简单的网络
                见WPS图.

        对Cisco (思科模拟器)的界面简单介绍:

            既然是多台主机之间的通信，那么就需要主机。
            左下角就是一些物理设备：
            如：
                Routerss:路由器
                switches:交换机
                Hubs:集线器
                ...


    通过交换机实现主机之间的通信：
            我们找到并点击：End Dexvces:就会出来 PC、Laptop-PT、server-PT
                1.我们点击PC并放置主机，然后再点击该主机，会显示当前主机的一些信息:
                    包括物理信息（physical）、配置（config）(在这里可以设置当前主机的名字、网关、DNS服务器等等，其中以太网（FastEthernet）里面可以配置它所对应的一些别的信息，包括默认分配的一个MAC地址，也可以配置IP地址以及子网掩码）
                    、Desktop（桌面）提供了一些软件，可以用来配置IP地址的，所以既可以通过软件来配置，也可以通过config来配置。甚至可以模拟浏览器Web B/S的操作；以及command进入命令窗口。Termminal终端。
                2.放置交换机switch:
                    我们鼠标放到交换机上面可以看到，该交换机有24个口。所以可以连接24台主机。
                3.要让主机与交换机之间连通：点击闪电的图标。第一个(黄色闪电)就是普通网线的图标,依次点击PC和switch进行连通
                    当四台PC都与交换机连通之后，我们再用鼠标看switch信息可以发现，其前4个link从down变成了up。
                4.完成连接之后，此时由于还没有配置信息，所以还不能进行通信。因此我们需要先配置网络：首先配置PC0:可以在config配置，也可在Desktop配置:
                    1.点击Ip,然后选择static（静态配置方式）
                    2.IP随便设置：192.168.3.11
                    3.点击子网掩码后，他会自动分配一个子网掩码
                    4.我们知道：如果要通过交换机实现多台主机通信，那么就必须要保证这些主机的IP地址在同一网段。
                    5.在config或Desktop设置IP地址。192.168.3.11   192.168.3.12   192.168.3.13   192.168.3.14
                5.配置完后看看能不能通信：打开PC0的窗口位置，点击Desktop，再点击command Prompt,此时就可以敲一些命令了。如：我想要看PC0能否与PC3通信：ping + PC3的IP地址。
                        即： ping 192.168.3.14
                        若回车之后打印信息里面有0%的数据包丢失，说明PC0和PC3是完全可以通信的。
                6.那么接下来，想要看他每一步到底是怎么一回事，就需要点击右下角的Simulation仿真。之前是Realtime实时。
                    1.使用PC1 ping 一下 PC2.
                        此时可以看到，PC1首先发送了一个ICMP 和 ARP数据包，
                            对于ARP数据包：
                                左边输入（In Layers），
                                右边输出(Out Layers):
                                    我们可以看到，它是通过的OSI的7层结构 其第二层(以太网，链路层)含有的信息：
                                        Layer 2:Ethernet II Header 00E0.B0CC.19CB
                                        >>FFFF.FFFF.FFFF ARP Packet Src. IP:
                                        192.168.3.12,Dest IP:192.168.3.13

                                        解读：00E0.B0CC.19CB:原MAC地址。FFFF.FFFF.FFFF:目的MAC地址（此处为广播地址）。
                                             192.168.3.12：原IP地址 192.168.3.13目的IP地址。
                                    可以点击Outbound PUD Details显示得更加全面：
                                        里面显示的就是网络数据包的协议构成。
                    2.继续执行：点击Auto Capture/Play
                    3.此时数据包从PC1发给了交换机。交换机接收到数据的时候，他就把数据发送给了所有的主机，PC0和PC3丢掉。PC2回发了数据给交换机，然后交换机将回发的数据发给了PC1.
                        这时的所有的数据包类型的都是ARP,说白了Ping命令用是ICMP，但ARP是我们的地址解析协议。

                        回到起始点，当运行到：PC1把数据包发送到交换机时，点击数据包，可以看到，交换机所运行的只是以太网物理层，也就意味着交换机已经确定了对应的一些信息。相当于保存了每一台主机所对应的MAC地址。所以每一个交换机对应的都有一个MAC地址表。
                        通过MAC地址表就可以得到下一个主机的走向问题，所以可以看到是从第二个接口 到第三个接口：Layer 1: Port FastEthernet0/2     到   Layer 1:Port(s):FastEthernet0/3。
                    4.再点击继续，数据发送到PC2,此时再看数据包。数据包里面就相当于在判断网络层。原IP地址3.12 ，目的IP地址3.13 没有问题。
                        由于是ping命令，我给你发，你也得回，所以，输出就变成了：原IP地址3.13 目的IP地址3.12。 此时就不再是发送广播了。而是经过交换机直接回到PC1。
                        到此为止，第一趟ping命令就完成了。

                    5.再之后第二次回发、第三次回发...在这时出现STP的原因在于：由于ping命令有一定的时间要求。如果说时间太长，ping命令就会无效。所以最好复位后再重新来。


            举例
                每台 PC 必须手动设置 ip、netmask
                192.168.1.1/255.255.255.0 ……
                192.168.1.8/255.255.255.0
                参考演示 demo-1

            总结：
                如果 PC 不知目标 IP 所对应的 MAC，那么可以看出，PC 会先发送 ARP 广播，得到对方的 MAC 然后，再进行数据的传送

                当 switch交换机 第一次收到 ARP 广播数据，会把 ARP 广播数据包转发给所有端口（除来源端口）；如果以后还有PC 询问此 IP 的 MAC，那么只是向目标的端口进行转发数据

                每台 PC 都会有一个 ARP 缓存表，用来记录 IP 所对应的的 MAC

                （在windows下面获取ARP表：arp -a,注意：ARP表也是临时的，不是说永久的，过一段时间就会将没有通信的主机的IP地址及其MAC地址从表中移除，下次通信再添加）
                （注意必须同一网段）


    5.3 通信过程（PC+switch+router）（通过路由器实现 不同网段 的通信）
        5.3.1 路由器介绍
        路由器（Router）又称网关设备（Gateway）是用于连接多个逻辑上分开的网络
            所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成
            具有判断网络地址和选择 IP 路径的功能
    （交换机主要工作在链路层，而路由器主要工作在网络层可以实现不同网段的主机之间进行通信，所以它可以选择网络地址和IP路径。）

        5.3.2 通信过程（PC+switch+router）
            通过 2 个 router，2 个 switch，4 台 PC 组成的网络
                如图：


    通过交换机实现主机之间的通信：
            路由器Physical里面可进行物理的断电开电。中间的就是网口。consig里面只有 FastEthernet0/0 和 FastEthernet0/1 两个网口，但现在要让四台主机进行连接，所以需要用到两个路由器，并且路由器之间也需要连通。
            所以一般是需要用到交换机，将主机都连接到交换机上，再将交换机连接到路由器上。、
            相当于PC0、PC1、交换机0与路由器0之间形成一个网段， PC2、PC3、交换机1、路由器1形成另一个网段，两个路由器之间形成第三个网段。
            1.连接好图
            2.配置4个PC的IP信息。
            3.配置路由器的信息：
                FastEthernet0/0 和 FastEthernet0/1,并且路由器的网口默认是关闭的需要打开：On.
                分别给两个路由器配置IP地址：
            4.当PC0（192.168.1.11） ping PC2 （192.168.2.11）时，直接报错：Layer 3:ICMP Message Type: 8
                当访问的不是同一网段，有如下性质：如果一台主机 要与 不是同一网段的主机进行通信，那么他会先把数据包发送给路由器，但主机是不知道谁是路由器的。
                他会把Router0这个路由器，当作是一台主机。所以需要配置路由器的 默认网关：Default Gateway。默认网关的作用：当当前主机想要与不同网段的主机进行通信时，会把数据先交给默认网关。
            5.配制网关：如：PC0 的IP configuration里面的Default Gateway输入路由器的IP地址。
            6.仿真结果：
                1.PC0初始发送数据包：
                        Layer 3: IP Header Src. IP:             1.网络层：IP地址：
                        192.168.1.11,Dest IP:                       原IP地址   :192.168.1.11
                        192.168.2.11 1CMP Message Type: 8           目的IP地址：192.168.2.11

                        Layer 2: Ethernet II Header             2.但MAC地址：
                        0001.978E.43DA >>                           原MAC地址：0001.978E.43DA   PC0的MAC地址
                        0001.642D.2501                              目的MAC地址：0001.642D.2501 路由器0的MAC地址

                        Layer 1: Port(s): FastEthernet
                由1、2可知：数据包是直接发送给了路由器的。
                (数据包直接发送给交换机，交换机通过比对MAC地址，将数据包交给了路由器，路由器就会拿到数据包并 报错:由于是要与2.0网段的主机通信，但此时路由器的原IP地址：1.1，但目的IP地址是1.11，即把数据往回发。而我们请求的是：原1.11，目的2.11.对于当前路由器而言，它不知道发给谁。
                所以要想把数据发到下一站，就得设置当前路由器的下一站，即：从路由器 往后发往哪一个路由器。所以需要配置路由器。
            7.配置路由器：
                在config里面有一个专门设置路由器的：Static Routes.用于设置静态的下一跳。
                    Network：设置IP地址。即：想要访问的网段 ：192.168.2.0
                    Mask：子网掩码。:255.255.255.0
                    Next Hop:下一跳的网段。这里必须得是3.1，不能是2.1,因为2.1与路由器0（内含有1.0和3.0两个网段）不在同一网段。注意：一个路由器的两个网段（网口）之间可以直接自由通信。
                            所以1网段，想要与2网段通信，就要从路由器0跳到路由器1。所以设置下一跳的IP地址是：192.168.3.12。
                点击添加ADD。
            8.再次仿真、
                当数据包走到路由器时我们可以看到：输出端的网络层是 原1.11 目的2.11。而链路层是
                    Layer 2:Ethernet Il Header
                    0001.9794.D102>>000A.412D.0B37  :由原MAC地址：0001.9794.D102发往目的MAC地址000A.412D.0B37 ，即：由路由器0的第二个网口发往路由器1的第一个网口。
                    Layer 1:Port(s): GigabitEthernet0/1
                路由器1接收到数据包后发给PC2主机。然后个人PC2主机回发数据也回经过路由器1，所以路由器1也得设置下一跳的IP地址。

            举例：
            配置所有 PC 的 IP、netmask
                PC0（192.168.1.1/24）
                PC1（192.168.1.2/24）
                PC2（192.168.3.1/24）
                PC3（192.168.3.2/24）
            配置 router（每个 router 有 2 个 IP）
                router0(192.168.1.254/24,192.168.2.1/24)
                router1(192.168.3.254/24,192.168.2.2/24)

            配置后的网络信息如图

            参考演示 demo-2(PC0 ping PC3)

            总结：
                不在同一网段的 PC，需要设置默认网关才能把数据传送过去
                通常情况下，都会把路由器设为默认网关
                当路由器收到一个其它网段的数据包时，会根据“路由表”来决定把此数据包发送到哪个端口；
                路由表的设定有静态和动态方法
                设置路由表就是设置下一跳，指定当前网段的主机与另一个网段主机通信时数据报应该发给哪个。



            在 dos 控制端下，可通过输入命令查看路由表
            再Windows下可以通过：
                route print查询路由表的信息。


    5.4 通信过程（浏览器跨网访问 Web 服务器）
        网络通信过程（复杂）
        以 PC0 访问 www.helloworld.com 举例
        配置网络设备
            PC：IP、NETMASK、DFGATEWAY、DNS
            ROUTER：IP、NETMASK、路由表

        总结
            1、DNS 服务器的作用是解析出 IP
            2、DFGATEWAY 指定发往其它网段的数据包转发的路径
            3、在路由器中路由表指定数据包的“下一跳”的地址
            4、公有 IP、私有 IP
*/

//第六章：原始套接字：(学了本章就可以研究每一个协议的构成、并且自己组数据包发送)
/*
    6.1 TCP、UDP 开发回顾
        套接字 分为：
            数据报套接字
            流式套接字

        数据报式套接字（SOCK_DGRAM）:用于UDP
            1、无连接的 socket,针对无连接的 UDP 服务
            2、可通过邮件模型来进行对比
        流式套接字（SOCK_STREAM）：用于TCP
            1、面向连接的 socket,针对面向连接的 TCP 服务
            2、可通过电话模型来进行对比

        这两类套接字似乎涵盖了 TCP/IP 应用的全部

        TCP 与 UDP 各自有独立的 port 互不影响
        一个进程可同时拥有多个 port
        不必关心 tcp/ip 协议实现的过程


        6.1.1 UDP 编程回顾
        client：
            1、创建 socket 接口
            2、定义 sockaddr_in 变量，其中 ip、port 为目的主机的信息
            3、可发送 0 长度的数据包
        server：
            1、bind 本地主机的 ip、port 等信息
            2、接收到的数据包中包含来源主机的 ip、port 信息(recvfrom：接收对方的数据、IP地址和端口号)

        6.1.2 TCP 编程回顾
        client
            connect 来建立连接
            send、recv 收发数据
            不可发送 0 长度的数据
        server
            bind 本地主机的 ip、port 等信息
            listen 把主动套接字变为被动
            accept 会有新的返回值
            多进程、线程完成并发


    6.2 原始套接字概述、创建
        6.2.1 原始套接字概述
            原始套接字（SOCK_RAW）
                1、SOCK_RAW（接收所有数据包）一种不同于 SOCK_STREAM（只能接收TCP的数据包）、SOCK_DGRAM(只能接收UDP的数据包) 的套接字，它实现于系统核心
                2、可以接收本机网卡上所有的数据帧（数据包）,对于监听网络流量和分析网络数据很有作用
                3、开发人员可发送自己组装的数据包到网络上（流式套接字和数据报套接字不论是链路层、网络层或传输层都没法改变，只能改变应用层的数据。但原始套接字不论是链路层、网络层、传输层都是可以自己组装的。）
                4、广泛应用于高级网络编程
                5、网络专家、黑客通常会用此来编写奇特的网络程序

            流式套接字只能收发
                TCP 协议的数据
            数据报套接字只能收发
                UDP 协议的数据
            原始套接字可以收发：
                任意的
                1、内核没有处理的数据包，因此要访问其他协议
                2、发送的数据需要使用，原始套接字(SOCK_RAW)


            6.2.2 创建原始套接字
            int socket(int domain, int type, int protocol)

            int socket(PF_PACKET, SOCK_RAW, protocol)
            功能：
                创建链路层的原始套接字
            参数：
                domain:通信域，地址族
                    AF_PACKET / PF_PACKET
                type:套接字类型
                    SOCK_RAW
                protocol：指定可以接收或发送的数据包类型
                    ETH_P_IP:IPV4 数据包
                    ETH_P_ARP:ARP 数据包
                    ETH_P_ALL:任何协议类型的数据包
                    这三个宏是在：#include <netinet/ether.h>里面定义的。所以需要加该头文件。
            返回值：
                成功(>0):链路层套接字 文件描述符
                失败(<0):出错         -1


            6.2.3 创建链路层的原始套接字
            头文件：
                #include <sys/socket.h>
                #include <netinet/ether.h>
            sock_raw_fd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));已过时，不再使用

            sock_raw_fd = socket(AF_INET, SOCK_PACKET, htons(ETH_P_ALL));现在一般使用。

            例：注意：原始套接字的代码运行时需要管理员权限
            注意：在执行的时候，由于原始套接字相当于要访问较底层的东西，所以运行的时候需要加权限。sudo
            因此，从此处开始乃至后面的网络编成都需要加sudo管理员权限去执行。

                    #include <sys/socket.h>
                    #include <sys/types.h> //socket
                    #include <netinet/ether.h> //ETH_P_ALL
                    #include <unistd.h> //close
                    #include <stdlib.h> //exit
                    #include <stdio.h> //printf
                    #include <arpa/inet.h>

                    int main(int argc, char const *argv[])
                    {
                        //使用socket函数创建链路层的原始套接字
                        int sockfd;
                        //对于：ETH_P_ALL需要将主机字节序转为网络字节序，然后去使用。
                        if((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) == -1)
                        {
                            perror("fail to sockfd");
                            exit(1);
                        }

                        printf("sockfd = %d\n", sockfd);

                        //关闭套接字文件描述符
                        close(sockfd);
                        //注意：在执行的时候，由于原始套接字相当于要访问较底层的东西，所以运行的时候需要加权限。sudo
                        //因此，从此处开始乃至后面的网络编成都需要加sudo管理员权限去执行。
                        return 0;
                    }



        6.3 数据包详解
            使用原始套接字进行编程开发时,首先要对不同协议的数据包进行学习,需要手动对 IP、TCP、UDP、ICMP 等包头进行组装或者拆解
            ubuntu12.04 中描述网络协议结构的文件如下：
                /usr/include/netinet# ls
                /usr/include/net# ls

            在 TCP/IP 协议栈中的每一层为了能够正确解析出上层的数据包，从而使用一些“协议类型”来标记，详细如下图
                见WPS图。

            6.3.1 组装/拆解 udp 数据包流程
                见图。
            确定在应用层的数据之前的这些协议，如TCP、IP、以太网这些协议内部到底是怎么组成的。
            只有知道怎么组成的，才能去使用。
                组装：从以太网开始组装，在拆解的时候同样也是从以太网的位置开始拆解的。


    一下几节可以见手册：网络变成附录（第六章的资料里面，附录A讲了每一个我们所要使用的协议头的组成部分，并且解释了每一个到底怎样去使用，
            附录B主要讲了：在编程的时候我们可能会用到的一些协议头所对应的结构体。）
            6.3.2 UDP 封包格式:
                UDP的报头占8个字节，32位。
                16位源端口号：2字节，源端口号
                16位目的端口号：2字节，目的端口号
                16位UDP长度：头部+数据（偶数个字节，不足补0） 长度
            1.源端口号：发送方端口号
            2.目的端口号：接收方端口号
            3.长度：UDP用户数据报的长度，最小值是8（仅有首部）
            4.校验和：头部+数据部分的校验。检测UDP用户数据报在传输中是否有错，有错就丢弃


            6.3.3 IP 封包格式
                IP报头每一行也是32位，即8字节，固定的内容有前5行，故，共20字节。，32位的选项一般不用。所以一般情况下IP报头就是20字节。

                1.版本：4位，IP协议的版本，常用IPv4。                                                                 （故，该位传4）
                2.首部长度：按理应传20，但1111，最大也才15，传不了20。                                                   (注意：该位以4字节为单位，所以报头20字节 = 5*4字节。所以改为传5。）
                3.服务类型：一般不适用，取值为0。前3位：优先级，第4-7位：延时，吞吐量，可靠性，花费。第8位保留                   (一般不适用，取值为0。)
                4.总长度：指首部加上数据的总长度，单位为字节。最大长度为65535字节。                                         (头部+数据长度。字节为单位，共65535字节。一般情况下IP协议是网络层的，所以再往下就是传输层（UDP/TCP），传输层之后才是应用层，即：应用数据，也就意味着：对于IP报头，它的数据就是  TCP头/UDP头 + 应用层的数据。所以总长度需要在确定了 TCP还是UDP 以及应用层数据之后才能进行传递)
                5.标识（identification）：用来标识主机发送的每一份数据报。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。                   (标识：标识主机发送的每一份数据报，IP软件在存储器中维持一个计数器，每产生一个数据报，计数器+1，并将此值赋给标识字段。自己组包，默认赋值0即可)
                6.标志（flag）：目前只有两位有意义。（相当于这两位都为0：最后一个，并且都允许分片）
                 标志字段中的最低位记为MF。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。
                 标志字段中间的一位记为DF，意思是“不能分片”，只有当DF=0时才允许分片
                7.片偏移：指出较长的分组在分片后，某片在源分组中的相对位置，也就是说，相对于用户数据段的起点，该片从何处开始。片偏移以8字节为偏移单位。（也设置为0）
                8.生存时间：TTL，表明是数据报在网络中的寿命，即为“跳数限制”，由发出数据报的源点设置这个字                        （生存时间：就是数据报能够被路由器转发的次数，若到达次数，就会直接丢弃该数据报，通常设32、64、128，一般设128）
                段。路由器在转发数据之前就把TTL值减一，当TTL值减为零时，就丢弃这个数据报。通常设置为32、
                64、128。
                9.协议：指出此数据报携带的数据时使用何种协议，以便使目的主机的IP层知道应将数据部分上交给
                哪个处理过程，常用的ICMP(1),IGMP(2),TCP(6),UDP(17),IPv6（41）       一般6和17用得最多。
                10.首部校验和：只校验数据报的首部，不包括数据部分。
                11.源地址：发送方IP地址
                12.目的地址：接收方IP地址
                13.选项：用来定义一些任选项；如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机
                和路由器都支持这些选项。一般忽略不计。

            6.3.4 Ethernet 封包格式（见网络编程手册）
                MAC头部：（见网络编程附录）
                    1.目的地址：目的MAC地址。
                    2.源地址：源MAC地址。
                    3.类型：确定MAC后面跟的是什么。
                            如果是0x0800 就是IP数据报
                            如果是0x0806 就是ARP数据请/应答
                            如果是0x8035 就是RARP请求/应答
                    4.数据：数据根据类型来决定。

                        后面跟的CRC、PAD：在组包时可以忽略。
                            CRC是循环冗余校验码：是数据通信领域中最常用的一种查错校验码，其特征是 信息字段 和 校验字段的长度 可以任意选定。
                            循环冗余检查是一种数据传输检错功能，对数据进行h多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，
                            以保证数据传输的正确性和完整性。



            6.3.5 TCP 封包格式
                首先一行还是4个字节。共5行，即20字节。
                    1.源端口号  ：发送方端口号
                    2.目的端口号：接收方端口号。
                    3.序列号：本报文段的数据的第一个字节的序号。
                    4.确认序号：期望收到对方下一个报文段的第一个数据字节的序号。（如：我发的是1，期望对方发我的是2.）
                    5.头部长度：4字节为单位，由于报头一共20字节，所以也传5。
                    6.保留：占6位，保留为今后使用，目前置为0即可。
                        7.紧急URG：此位置1，表示紧急指针字段有效，他告诉系统此报文段中有紧急数据，应尽快传送
                        8.确认ACK：仅当ACK为1时，确认字段才有效，TCP规定，在连接建立后所有传达的报文段都必须把ACK置1。（TCP的三次握手中，当对方给我发的是SYN时，我方就需要回一个ACK）
                        9.推送PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即
                            就能够收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作，这时，发送方TCP把PSH
                            置1，并立即创建一个报文段发送出去，接收方收到PSH=1的报文段，就尽快地（即“推送”向前）交
                            付给接收应用进程，而不再等到整个缓存都填满后再向上交付   一般设为0，用得上再置1.
                        10.复位RST: 用于复位相应的TCP连接
                        11.同步SYN: 仅在三次握手建立TCP连接时有效。当SYN=1而ACK=0时，表明这是一个连接请求报文段，
                            对方若同意建立连接，则应在相应的报文段中使用SYN=1和ACK=1.因此，SYN置1就表示这是一个连接请
                            求或连接接受报文
                        12.终止FIN：用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并要求释放运输连接。
                    13.窗口：指 发送本报文段的一方 的接收窗口（而不是自己的发送窗口）
                    14.校验和：校验和字段检验的范围包括首部和数据两部分，在计算校验和时需要加上12字节的伪头部
                    15.紧急指针：仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数据
                    16.选项：长度可变，最长可达40字节，当没有使用选项时，TCP首部长度是20字节

            6.3.6 ICMP 封包格式
            （通过仿真我们知道，ICMP是网络层的协议，是IP数据报后面跟的协议）
            所以在使用ICMP的时候，前面要有IP协议数据报。

            一共两行，每行4个字节。
                1.类型：8位
                2.代码：8位
                        类型和代码一般连起来用：
                            类型      代码      描述
                            0         0        回显应答
                            8         0        回显请求

                我们在仿真中知道：ICMP最常用的地方就是ping命令中。
                ping命令就是利用ICMP协议实现检测两台主机是否能够通信。所以有应答和请求两项。

                3.校验和：16位
                    要包括报头、选项和数据
                4.标示符：16位
                5.序号：16位
            注意：
                不同的类型值以及代码值，代表不同的功能

    6.4 编程实例—分析 MAC 数据包
        抓取一个数据报，然后分析其源MAC、目的MAC、类型等数据。

        6.4.1 链路层数据格式
            见WPS
        6.4.2 示例效果
            见WPS
        6.4.3 参考代码
        02:直接sudo执行即可。
                #include <sys/socket.h>
                #include <sys/types.h> //socket
                #include <netinet/ether.h> //ETH_P_ALL
                #include <unistd.h> //close
                #include <stdlib.h> //exit
                #include <stdio.h> //printf
                #include <arpa/inet.h> //htons

                #define ERRLOG(errmsg) do{\
                                            perror(errmsg);\
                                            exit(1);\
                                        }while(0)

                int main(int argc, char const *argv[])
                {
                    //创建原始套接字
                    int sockfd;
                    if((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) < 0)
                    {
                        ERRLOG("fail to socket");
                    }

                    //printf("sockfd = %d\n", sockfd);

                    //接收数据并分析
                    unsigned char msg[1600] = "";
                    while(1)
                    {
                        //recvfrom recv read 都可以使用
                        if(recvfrom(sockfd, msg, sizeof(msg), 0, NULL, NULL) < 0)
                        {
                            ERRLOG("fail to recvfrom");
                        }

                        //分析接收到的数据包
                        unsigned char dst_mac[18] = "";
                        unsigned char src_mac[18] = "";
                        unsigned short type;
                        sprintf(dst_mac, "%x:%x:%x:%x:%x:%x", msg[0], msg[1], msg[2], msg[3], msg[4], msg[5]);
                        sprintf(src_mac, "%x:%x:%x:%x:%x:%x", msg[6], msg[7], msg[8], msg[9], msg[10], msg[11]);
                        type = ntohs(*(unsigned short *)(msg + 12));

                        printf("源mac：%s --> 目的mac：%s\n", src_mac, dst_mac);
                        printf("type = %#x\n", type);
                    }

                    return 0;
                }

    6.5 练习—网络数据分析器
        在很多时候需要对网络上的数据进行抓取，然后进行分析，此“网络数据分析器”就是模仿现实开发中的抓包工具而进行的
        运行 demo 现象如下：

        6.5.1 网络数据分析图
            见WPS。

        6.5.2 ARP 数据解析图
            见WPS

        arp协议的作用：通过对方的IP地址获取对方的MAC地址。（arp用得更多）
            1.arp请求：
            2.arp应答：
        而rarp协议刚好相反：通过对方的MAC地址获取其IP地址。
            3.rarp请求：
            4.rarp回复：

            说明:
                1、ARP 的 TYPE 为 0x0806
                2、buf 为 unsinged char,只要是涉及到数据，都是无符号类型的。
                3、所有数据均为大端（所以，如果获取到的内容超过一个字节，即：两个字节及以上。则需要进行转化：将主机字节序转化为网络字节序。或将网络字节序转化为主机字节序，区别就是看：发送还是获取）

        6.5.3 IP 数据解析图（以太网类型后面跟0x0800对应的就是IP数据包）
                见WPS,
                类型（PRO）:
                    1.ICMP
                    2.IGMP
                    6.TCP
                    17.UDP(0x11)
            说明：
                1、IP 的 TYPE 为 0x0800
                2、buf 为 unsinged char
                3、所有数据均为大端

                如下图所示，是网上的数据包的组包过程；其解包过程正好相反，首先分析以太网得到 MAC 然后再依次分析，
              比如 IP、PORT 等等
                    见WPS.


        6.5.4 要求
            要求：
                1、分析出 ARP/IP/RARP
                2、分析出 MAC
            扩展：
                在完成基本要求的前提下，分析 PORT
            提示：
                以 root 权限运行
            想一想：
                如何捕捉途经网卡的数据?
                06-01-data-analysis.c
            案例：
                    #include <sys/socket.h>
                    #include <sys/types.h> //socket
                    #include <netinet/ether.h> //ETH_P_ALL
                    #include <unistd.h> //close
                    #include <stdlib.h> //exit
                    #include <stdio.h> //printf
                    #include <arpa/inet.h> //htons

                    #define ERRLOG(errmsg) do{\
                                                perror(errmsg);\
                                                exit(1);\
                                            }while(0)

                    //网络数据分析器
                    int main(int argc, char const *argv[])
                    {
                        //创建原始套接字
                        int sockfd;
                        if((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) < 0)
                        {
                            ERRLOG("fail to socket");
                        }

                        //printf("sockfd = %d\n", sockfd);

                        //接收数据并分析
                        unsigned char msg[1600] = "";
                        while(1)
                        {
                            //recvfrom recv read 都可以使用
                            if(recvfrom(sockfd, msg, sizeof(msg), 0, NULL, NULL) < 0)
                            {
                                ERRLOG("fail to recvfrom");
                            }

                            //分析接收到的数据包
                            unsigned char dst_mac[18] = "";
                            unsigned char src_mac[18] = "";
                            unsigned short type;
                            sprintf(dst_mac, "%x:%x:%x:%x:%x:%x", msg[0], msg[1], msg[2], msg[3], msg[4], msg[5]);
                            sprintf(src_mac, "%x:%x:%x:%x:%x:%x", msg[6], msg[7], msg[8], msg[9], msg[10], msg[11]);
                            type = ntohs(*(unsigned short *)(msg + 12));

                            printf("源mac：%s --> 目的mac：%s\n", src_mac, dst_mac);
                            printf("type = %#x\n", type);

                            if(type == 0x0800)
                            {
                                printf("ip数据报\n");

                                //头部长度、总长度
                                unsigned char ip_head_len;
                                unsigned short ip_len;
                                ip_head_len = ((*(unsigned char *)(msg + 14)) & 0x0f) * 4;  //以4字节为单位，所以乘4
                                ip_len = ntohs(*(unsigned short *)(msg + 16));
                                printf("ip头部：%d, ip数据报总长度: %d\n", ip_head_len, ip_len);

                                //目的ip地址、源IP地址
                                unsigned char dst_ip[16] = "";
                                unsigned char src_ip[16] = "";
                                sprintf(src_ip, "%u.%u.%u.%u", msg[26], msg[27], msg[28], msg[29]);
                                sprintf(dst_ip, "%u.%u.%u.%u", msg[30], msg[31], msg[32], msg[33]);
                                printf("源ip地址：%s --> 目的ip地址：%s\n", src_ip, dst_ip);

                                //协议类型
                                unsigned char ip_type;
                                ip_type = *(msg + 23);
                                printf("ip_type = %d\n", ip_type);
                                //icmp、igmp、tcp、udp
                                if(ip_type == 1)
                                {
                                    printf("icmp报文\n");
                                }
                                else if(ip_type == 2)
                                {
                                    printf("igmp报文\n");
                                }
                                else if(ip_type == 6)
                                {
                                    printf("tcp报文\n");
                                    unsigned short src_port;
                                    unsigned short dst_port;
                                    src_port = ntohs(*(unsigned short *)(msg + 34));
                                    dst_port = ntohs(*(unsigned short *)(msg + 36));
                                    printf("源端口号：%d --> 目的端口号: %d\n", src_port, dst_port);
                                }
                                else if(ip_type == 17)
                                {
                                    printf("udp报文\n");
                                    //目的端口号、源端口号
                                    unsigned short src_port;
                                    unsigned short dst_port;
                                    src_port = ntohs(*(unsigned short *)(msg + 34));
                                    dst_port = ntohs(*(unsigned short *)(msg + 36));
                                    printf("源端口号：%d --> 目的端口号: %d\n", src_port, dst_port);
                                }
                            }
                            else if(type == 0x0806)
                            {
                                printf("arp数据报\n");
                                //源ip地址
                                //目的ip地址
                                unsigned char dst_ip[16] = "";
                                unsigned char src_ip[16] = "";
                                sprintf(src_ip, "%u.%u.%u.%u", msg[28], msg[29], msg[30], msg[31]);
                                sprintf(dst_ip, "%u.%u.%u.%u", msg[38], msg[39], msg[40], msg[41]);
                                printf("源ip地址：%s --> 目的ip地址：%s\n", src_ip, dst_ip);
                            }
                            else if(type == 0x8035)
                            {
                                printf("rarp数据报\n");
                            }

                            printf("\n*****************\n\n");
                        }

                        close(sockfd);

                        return 0;
                    }
        //执行结果：
            qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/6_RAM$ gcc 03_raw_recv.c
            qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/6_RAM$ sudo ./a.out
            源mac：0:0:0:0:0:0 --> 目的mac：0:0:0:0:0:0
            type = 0x800
            ip数据报
            ip头部：20, ip数据报总长度: 60
            源ip地址：127.0.0.1 --> 目的ip地址：127.0.0.1
            ip_type = 6
            tcp报文
            源端口号：50100 --> 目的端口号: 11311

            *****************

            源mac：0:0:0:0:0:0 --> 目的mac：0:0:0:0:0:0
            type = 0x800
            ip数据报
            ip头部：20, ip数据报总长度: 40
            源ip地址：127.0.0.1 --> 目的ip地址：127.0.0.1
            ip_type = 6
            tcp报文
            源端口号：11311 --> 目的端口号: 50100

        6.5.5 混杂模式
            非混杂模式：只有给我发送/我给别人发送的数据报，我才能够接收到。
            混杂模式（接收所有经过我 的数据）
                1、指一台机器的网卡能够接收所有经过它的数据包，而不论其目的地址是否是它。
                2、一般计算机网卡都工作在非混杂模式下，如果设置网卡为混杂模式需要 root 权限
            linux 下设置
                1、设置混杂模式：ifconfig eth0 promisc
                2、取消混杂模式：ifconfig eth0 -promisc
            windos 下通过特定的软件实现
            linux 下通过程序设置网卡混杂模式：
                struct ifreg ethreq;

                strncpy(ethreg.ifr name,"eth0"IFNAMSIZ);
                if(ioctl(sock_raw_fd,SIOCGIFFLAGS,&ethreq)!= 0)//获取eth0网络接口标志
                {
                    perror("ioctl");
                    close(sock_raw_fd);                 1.获取网络接口标志
                    exit(-1);
                }
                ethreq.ifr_flagS |= IFF_PROMISC:
                if(ioctl(sock_raw_fd, SIOCSIFFLAGS,&ethreq)!=0)//设置eth0网络接口标志
                {
                    perror("ioctl");
                    close(sock raw fd);                 2.设置网络接口标志
                    exit(-1);
                }



6.6 sendto 发送数据
    6.6.1 用 sendto 发送原始套接字数据
    sendto(sock_raw_fd, msg, msg_len, 0,(struct sockaddr*)&sll, sizeof(sll));
    注意：
        1、sock_raw_fd：原始套接字
        2、msg:发送的消息（封装好的协议数据）
        3、sll:本机网络接口，指发送的数据应该从本机的哪个网卡出去，而不是以前的目的地址
    想一想：
        如何定义 sll?
    6.6.2 本机网络接口
    结构体：
        struct sockaddr_ll sll;
    头文件；
        #include <netpacket/packet.h>
    struct sockaddr_ll
    {
        unsignef short int sll_family; //一般为PF_PACKET
        unsignef short int sll_protocol; //上层协议
        int sll_ifindex;                // * 接口类型
        unsignef short int sll_hatype; //报头类型
        unsignef char sll_pkttype; //包类型
        unsignef char sll_halen; //地址长度
        unsignef char sll_addr[8]; //MAC地址
    }

    只需要对 sll.sll_ifindex 赋值，就可使用

    6.6.3 发送数据 demo
        //将网络接口赋值给原始套接字地址结构
        struct sockaddr_ll sll;
        bzero(&sll,sizeof(sll))
        sll.sll_ifindex=    //获取本机要出去的接口地址;
        if((int len=sendto(sock_raw_fd,msg,sizeof(msg),0,(struct sockaddr*)&sll,sizeof(sll))) == -1)
        {
            perror("fail to sendto");
            exit(1);
        }

    6.6.4 通过 ioctl 来获取网络接口地址
        int ioctl(int fd, int request,void *)
        #include <sys/ioctl.h>
        ioctl 获取接口示例
            struct ifreg ethreg;                                //网络接口地址
            strncpy(ethreq.ifr_name,"eth0",IFNAMSIZ);           //指定网卡名称
            if(-1 == ioctl(sock_raw_fd,SIOCGIFINDEX,&ethreq))   //获取网络接口
            {
                perror("ioctl");
                close(sock_raw_fd);
                exit(-1);
            }                                           1.获取网络接口

            struct sockaddr_ll sll;
            bzero(&sll,sizeof(sll));
            sll.sll_ifindex = ethreq.ifr_ifindex;       2.给sll赋值

            int len = sendto(sock_raw_fd,msg,sizeof(msg)),0,(struct sockaddr*)&sll,sizeof(sll));    3.发送


        想一想：
            ioctl 的参数、struct ifreq 结构类型

        ioctl 参数对照表：
            类别      request         说明          数据类型
                 SIOCGIFINDEX    获取网络接口     struct ifreg
                 SIOCSIFADDR     设置接口地址     struct ifreg
             接口 SIOCGIFADDR     获取接口地址     struct ifreg
                 SIOCSIFFLAGS    设置接口标志     struct ifreg
                 SIOCGIFFLAGS    获取接口标志     struct ifreg

            struct ifreg ethreq;        //网络接口地址
            strncpy(ethreq.ifr_name,"eth0",IFNAMSIZ);//指定网卡名称
            ioctl(sock_raw_fd,SIOCGIFINDEX,&ethreq) //获取网络接口

        struct ifreq：#include <net/if.h>
        IFNAMSIZ 16
        sendto 发送数据的整体过程

            struct ifreg ethreq;    //网络接口地址
            strncpy(ethreg.ifr_name,"eth0"，IFNAMSIZ)://指定网卡名称
            if(-1 == ioctl(sock_raw_fd，SIOCGIFINDEX，&ethreg))//获取网络接口
            {
                perror("ioctl");
                close(sock_raw_fd)
                exit(-1);
            }                                   1.获取网络接口

            struct sockaddr_ll sll;
            bzero(&sll，sizeof(sll));
            sll.sll_ifindex= ethreg.ifr_ifindex;    2.给sll赋值

            int len=sendto(sock_raw_fd,msg,sizeof(msg)，0，(struct sockaddr*)&sll,sizeof(sll));3.发送

    完整发送的过程：1.通过ioctrl获取网络接口 2.设置本地网络接口（给sll_ifindex赋一个：ethreq当中的值：ifr_ifindex） 3.发送数据
        //获取接口信息
        //将 arp 请求报文发送出去，通过 eth0 发送出去
        //使用 ioctl 函数获取本机网络接口
        struct ifreq ethreq;
        strncpy(ethreq.ifr_name, "eth0", IFNAMSIZ);
        if(ioctl(sockfd, SIOCGIFINDEX, ðreq) == -1)
        {
            perror("fail to ioctl");
            exit(1);
        }
        //设置本机网络接口
        struct sockaddr_ll sll;
        bzero(&sll, sizeof(sll));
        sll.sll_ifindex = ethreq.ifr_ifindex;
        //发送数据
        if(sendto(sockfd, msg, sizeof(msg), 0, (struct sockaddr *)&sll, sizeof(sll)) < 0)
        {
            perror("fail to sendto");
            exit(1);
        }


6.7 练习—MAC 地址扫描器（ARP）（利用ARP协议完成：通过对方的IP地址获取对方的MAC地址）
    6.7.1 ARP 概述
        想一想：
            如果 A(192.168.1.1)向 B(192.168.1.2)发送一个数据包，那么需要的条件有 ip、port、使用的协议（TCP/UDP）
            之外还需要 MAC 地址，因为在以太网数据包中 MAC 地址是必须要有的；问怎样才能知道对方的 MAC 地址？使
            用什么协议呢？

        ARP（Address Resolution Protocol，地址解析协议）
            1、是 TCP/IP 协议族中的一个
            2、主要用于查询指定 ip 所对应的的 MAC
            3、请求方使用 广播 来发送请求
            4、应答方使用 单播 来回送数据
            5、为了在发送数据的时候提高效率在计算中会有一个 ARP 缓存表，用来暂时存放 ip 所对应的 MAC，在 linux
            中使用 ARP 即可查看,在 xp 中使用 ARP -a
    6.7.2 在 linux 与 windows 系统下查看 ARP 的方式：
        在Linux下查看arp表：
                使用arp命令
            例：
            qinmei@qinmei-virtual-machine:~/Linux_learn/src/2_net/6_RAM$ arp
            地址                     类型    硬件地址            标志  Mask            接口
            192.168.177.2            ether   00:50:56:f9:44:96   C                     ens33
            192.168.177.254          ether   00:50:56:f1:d9:71   C                     ens33

        在windows下面查看arp表：
            在命令行提示符中 使用命令： arp -a
            例：
                C:\Users\zhongqing>arp -a

                接口: 192.168.177.1 --- 0x8
                  Internet 地址         物理地址              类型
                  192.168.177.254       00-50-56-f1-d9-71     动态
                  192.168.177.255       ff-ff-ff-ff-ff-ff     静态
                  224.0.0.2             01-00-5e-00-00-02     静态
                  224.0.0.22            01-00-5e-00-00-16     静态
                  224.0.0.251           01-00-5e-00-00-fb     静态
                  224.0.0.252           01-00-5e-00-00-fc     静态
                  239.192.152.143       01-00-5e-40-98-8f     静态
                  239.255.255.250       01-00-5e-7f-ff-fa     静态
                  255.255.255.255       ff-ff-ff-ff-ff-ff     静态

                接口: 192.168.1.5 --- 0xb
                  Internet 地址         物理地址              类型
                  192.168.1.1           90-fd-73-03-1d-fa     动态
                  192.168.1.255         ff-ff-ff-ff-ff-ff     静态
                  224.0.0.2             01-00-5e-00-00-02     静态
                  224.0.0.22            01-00-5e-00-00-16     静态
                  224.0.0.251           01-00-5e-00-00-fb     静态
                  224.0.0.252           01-00-5e-00-00-fc     静态
                  239.192.152.143       01-00-5e-40-98-8f     静态
                  239.255.255.250       01-00-5e-7f-ff-fa     静态
                  255.255.255.255       ff-ff-ff-ff-ff-ff     静态

                接口: 192.168.137.1 --- 0x11
                  Internet 地址         物理地址              类型
                  192.168.137.255       ff-ff-ff-ff-ff-ff     静态
                  224.0.0.2             01-00-5e-00-00-02     静态
                  224.0.0.22            01-00-5e-00-00-16     静态
                  224.0.0.251           01-00-5e-00-00-fb     静态
                  224.0.0.252           01-00-5e-00-00-fc     静态
                  239.192.152.143       01-00-5e-40-98-8f     静态
                  239.255.255.250       01-00-5e-7f-ff-fa     静态
                  255.255.255.255       ff-ff-ff-ff-ff-ff     静态

                接口: 192.168.162.1 --- 0x13
                  Internet 地址         物理地址              类型
                  192.168.162.254       00-50-56-f6-8c-2c     动态
                  192.168.162.255       ff-ff-ff-ff-ff-ff     静态
                  224.0.0.2             01-00-5e-00-00-02     静态
                  224.0.0.22            01-00-5e-00-00-16     静态
                  224.0.0.251           01-00-5e-00-00-fb     静态
                  224.0.0.252           01-00-5e-00-00-fc     静态
                  239.192.152.143       01-00-5e-40-98-8f     静态
                  239.255.255.250       01-00-5e-7f-ff-fa     静态
                  255.255.255.255       ff-ff-ff-ff-ff-ff     静态

            注意:当主机A和主机B通信时，会先查看arp表中有没有对方的mac地址，如果有则直接通信即可
            如果没有再调用arp协议获取对方mac地址并将其保存在arp表中

            见WPS例子。

        6.7.3 ARP 协议格式

            详细见附录图；
                1.Dest MAC:目的MAC地址
                2.Src MAC：源MAC地址
                3.帧类型：0x0806
                4.硬件类型：1（以太网）
                5.协议类型：0x0800（IP地址）
                6.硬件地址长度：6
                7.协议地址长度：4
                8.OP：1（ARP请求），2（ARP应答），3（RARP请求），4（RARP应答）

        6.7.4 向指定 IP 发送 ARP 请求(demo)
            获取 172.20.226.11 的 MAC 地址
            要求
                获取到当前网段中所有机器的 MAC 地址
            提示
                1、每次指定一个机器发送 MAC 请求，通过发送多次 ARP，即可得到所有的机器的 MAC
                2、ARP 的发送和接收各使用一个线程
                MAC 地址扫描器运行现象如下图所示 06-02-sock_raw_arp.c

            例：
                    #include <sys/socket.h>
                    #include <sys/types.h> //socket
                    #include <stdio.h> //printf
                    #include <unistd.h> //close
                    #include <stdlib.h> //exit
                    #include <netinet/ether.h> //ETH_P_ALL
                    #include <netpacket/packet.h>  //sockaddr_ll
                    #include <sys/ioctl.h>  //ioctl
                    #include <net/if.h> //ifreq
                    #include <string.h> //strncpy
                    #include <strings.h> //bzero
                    #include <arpa/inet.h> //htons

                    #define ERRLOG(errmsg) do{\
                                                perror(errmsg);\
                                                exit(1);\
                                            }while(0)

                    //使用arp协议通过对方ip地址获取mac地址

                    int main(int argc, char const *argv[])
                    {
                        //创建原始套接字
                        int sockfd;
                        if((sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) < 0)
                        {
                            ERRLOG("fail to socket");
                        }

                        //组数据包
                        //源mac地址：00:0c:29:7b:35:d7
                        unsigned char msg[1600] = {
                            //组以太网首部
                            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //目的mac地址，广播地址
                            0x00, 0x0c, 0x29, 0x7b, 0x35, 0xd7, //源mac地址
                            0x08, 0x06, //帧类型 arp报文：0x0806

                            //组arp报文
                            0x00, 0x01, //硬件类型 以太网：1
                            0x08, 0x00, //协议类型 ip地址：0x0800
                            6, //硬件地址长度
                            4, //协议地址长度
                            0x00, 0x01, //op arp请求：1
                            0x00, 0x0c, 0x29, 0x7b, 0x35, 0xd7, //源mac地址
                            192, 168, 3, 103, //源ip地址
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //目的mac地址
                            192, 168, 3, 78   //目的ip地址
                        };

                        //获取接口信息
                        //将arp请求报文发送出去，通过ens33发送出去
                        //使用ioctl函数获取本机网络接口
                        struct ifreq ethreq;
                        strncpy(ethreq.ifr_name, "ens33", IFNAMSIZ);
                        if(ioctl(sockfd, SIOCGIFINDEX, &ethreq) == -1)
                        {
                            perror("fail to ioctl");
                            exit(1);
                        }

                        //设置本机网络接口
                        struct sockaddr_ll sll;
                        bzero(&sll, sizeof(sll));
                        sll.sll_ifindex = ethreq.ifr_ifindex;

                        //发送数据
                        if(sendto(sockfd, msg, 14 + 28, 0, (struct sockaddr *)&sll, sizeof(sll)) < 0)
                        {
                            ERRLOG("fail to sendto");
                        }

                        unsigned char recv_msg[1600] = "";
                        unsigned char mac[18] = "";
                        while(1)
                        {
                            //接收数据并分析
                            if(recvfrom(sockfd, recv_msg, sizeof(recv_msg), 0, NULL, NULL) < 0)
                            {
                                ERRLOG("fail to recvfrom");
                            }

                            //如果是arp数据包并且是arp应答，则打印源mac地址
                            if(ntohs(*(unsigned short *)(recv_msg + 12)) == 0x0806)
                            {
                                if(ntohs(*(unsigned short *)(recv_msg + 20)) == 2)
                                {
                                    sprintf(mac, "%x:%x:%x:%x:%x:%x", recv_msg[6], recv_msg[7], recv_msg[8], recv_msg[9], recv_msg[10], recv_msg[11]);
                                    printf("192.168.3.%d --> %s\n", msg[41], mac);
                                    break;
                                }
                            }
                        }

                        close(sockfd);

                        return 0;
                    }














































*/

//第七章 BS模式开发之Web编程
/*
    BS开发:浏览器、服务器模型。
        浏览器端需要写一些网页，才能与其他的服务器之间进行沟通。
    第一章：web及一些概念性内容
    第二章：网页端最基础的语言：HTML
    第三章：如何让编写的语言动起来：Javascript
    第四章：AJAX
    第五章：CGI

    1.1 概述
        1.1.1 常见的 Web 技术
        1、web 前端开发技术
        (1) HTML、CSS、XML、Javascript、AJAX
        HTML 简介:
            超文本标记语言(英文全称:HyperText Markup Language)
            “超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素
        CSS 简介：（让HTML写的网页更好看，用CSS）
            CSS: 层叠样式表(英文全称：Cascading Style Sheets)
            CSS 是一种定义样式结构如字体、颜色、位置等的语言，被用于描述网页上的信息格式化和现实的方式
        XML 简介：
            XML 指可扩展标记语言（EXtensible Markup Language）
            XML 是一种标记语言，很类似 HTML
            XML 的设计宗旨是传输数据，而非显示数据
            XML 是各种应用程序之间进行数据传输的最常用的工具
        Javascript 简介：
            JavaScript 是一种属于网络的脚本语言,已经被广泛用于 Web 应用开发,常用来为网页添加各式各样的
            动态功能,为用户提供更流畅美观的浏览效果。通常 JavaScript 脚本是通过嵌入在 HTML 中来实现自身的功能的。
        AJAX 简介：
            Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网
            页应用的网页开发技术

        2、Web 服务器端开发技术
        (1) CGI、ASP、PHP
            CGI 简介：（可理解为：服务器端的可执行程序，建立起来了服务器与网页端的通信）
                CGI（英文全称：Common Gateway Interface）通用网关接口
                CGI 是 Web 服务器运行时外部程序的规范,按 CGI 编写的程序可以扩展服务器功能。CGI 应用程序
            能与浏览器进行交互,还可通过数据库 API 与数据库服务器等外部数据源进行通信,从数据库服务器中获
            取数据。
                你可以简单的认为 CGI 程序是服务器端的一个可执行程序。
        ASP 简介：
            ASP（英文全称：Active Server Pages）动态服务器页面
            是MicroSoft公司开发的服务器端脚本环境，可用来创建动态交互式网页并建立强大的web应用程序。
            ASP 提供了一些内置对象，使用这些对象可以使服务器端脚本功能更强
        PHP 简介：
            PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。
            语法吸收了 C 语言、Java 和 Perl 的特点，利于学习，使用广泛，主要适用于 Web 开发领域

        3、数据管理
            (1) Oracle、MySQL、SQLServer、SQLite

        1.1.2 嵌入式 web 开发模型
        功能展示：
        模型：

        1.1.3 B/S 架构
        B/S 架构
        Browser/Server（浏览器/服务器结构），是随着 Internet 技术的兴起，是对 C/S 结构的一种变化或者改进的结构。

        用户界面完全通过 www 浏览器实现，一部分事物逻辑在前端实现，但是主要事务逻辑在服务器端实现。
        随着 Windows98/Windows2000 将浏览器技术植入操作系统内部，这种结构更成为当今应用软件的首选体系结
        构。

        B/S 架构 与 C/S 架构对比：
            C/S模式：              B/S模式：
            客户/服务器模式        浏览器/服务器模式
            胖客户/瘦服务器        瘦客户/胖服务器
            QQ、微信、飞信         浏览器就可完成操作
                                WebQQ、七雄争霸、洛克王国


            角度              C/S                     B/S
            硬件环境        专用网络                    广域网

            安全要求        面向相对固定的用户群          面向不可知的用户群
                        信息安全的控制能力很强         对安全的控制能力相对弱

            程序架构      更加注重流程                    对安全以及访问速度要多重的考虑
                        系统运行速度可较少考虑         B/S结构的程序架构是多发展的趋势

            软件重用        差                           好
            系统维护        升级难                     开销小、方便升级
            处理问题        集中                      分散
            用户接口        与操作系统关系密切           跨平台，与浏览器相关
            信息流         交互性低                    交互密集



        1.1.4 Web 原理
            见图：
                用户端通过HTTP将请求传递到Web服务器。Web服务器再将数据存储到数据库、后端处理、传统系统当中最终控制硬件。控制完硬件，它给一个反馈之后再将数据传给web服务器。
                web服务器再通过HTML+CSS等数据再给用户界面进行交互。
                所以BS就是通过超文本协议，HTTP协议来实现通信的。

        1.1.5 boa web 服务器移植
                boa web服务器就是比较成熟的服务器，不是我们那种稚嫩的服务器。
                但我们Ubuntu当中原本是没有该服务器的，所以我们需要下载源码，并安装。
                第七章->资料->boa-0.94.13.tar.gz(该压缩包就是boa的源码)，资料中还有ubuntu搭建boa服务器的帮助文档。

            详情参见文档
                        Ubuntu搭建boa服务器
        1.下载源码：
            资料中的 boa-0.94.13.tar.gz压缩包
        2.创建所需目录文件
               在/home/share 下： 创建四个文件：
                    qinmei@qinmei-virtual-machine:~$ cd share/
                    qinmei@qinmei-virtual-machine:~/share$ mkdir myboa
                    qinmei@qinmei-virtual-machine:~/share$ cd myboa/
                    qinmei@qinmei-virtual-machine:~/share/myboa$ mkdir boa              //主要用于存放boa服务器的可执行文件和配置文件
                    qinmei@qinmei-virtual-machine:~/share/myboa$ mkdir log              //存放日志文件、便于调试
                    qinmei@qinmei-virtual-machine:~/share/myboa$ mkdir www              //存放网页和一些资源
                    qinmei@qinmei-virtual-machine:~/share/myboa$ mkdir www/cgi-bin      //存放cgi程序
                    qinmei@qinmei-virtual-machine:~/share/myboa$ cd ..
                    qinmei@qinmei-virtual-machine:~/share$ tree myboa/
                    myboa/
                    ├── boa
                    ├── log
                    └── www
                        └── cgi-bin

                    4 directories, 0 files
        3.安装需要的工具:执行两个命令
            sudo apt-get install bison
            sudo apt-get install flex
        4 -- 对下载的源码解压缩
            tar -xzf boa-0.94.13.tar.gz
        5 -- 进入 src 目录并执行配置文件
                cd src
                ./configure
        6 -- 修改一些文件
            (1)修改 defines.h 中的内容 将 #define SERVER_ROOT "/boa" 修改为自己指定
            的目录 例如：#define SERVER_ROOT "/home/linux/share/myboa/boa" 其中/boa
            为以后 boa 程序运行的配置文件 boa.conf 存放的路径
            (2)修改 boa.c 中的内容
            将 225 行左右的内容
            if (setuid(0) != -1) {
                DIE("icky Linux kernel bug!");
            }
            注释掉
            (3)修改 compat.h 中的 120 行左右内容
            将 #define TIMEZONE_OFFSET(foo) foo##->tm_gmtoff
            修改为 #define TIMEZONE_OFFSET(foo) (foo)->tm_gmtoff
        7 -- 进行编译
            make
        8 -- 复制所需文件
        (1)将 boa-0.94.13/src 目录下生成的两个二进制文件复制到指定的 boa 目录下
            cp boa /home/lzx/share/myboa/boa
            cp boa_indexer/home/lzx/share/myboa/boa
        (2)将 boa-0.94.13 目录下的 boa.conf 复制到指定的 boa 目录下
            cp boa.conf /home/lzx/share/myboa/boa
        9 -- 在 log 目录下创建文件
            touch /home/lzx/share/myboa/log/error_log
            touch /home/lzx/share/myboa/log/access_log
        10 -- 修改复制后的 boa.conf 文件
            cd /home/lzx/share/myboa/boa
            vi boa.conf
            修改一下内容：
            ...
            User 0 Group 0
            ...
            ErrorLog /home/lzx/share/myboa/log/error_log
            ...
            AccessLog /home/lzx/share/myboa/log/access_log
            ...
            DocumentRoot /home/lzx/share/myboa/www
            ...
            DirectoryMaker /home/lzx/share/myboa/boa/boa_indexer
            ...
            ScriptAlias /cgi-bin/ /home/lzx/share/myboa/www/cgi-bin/
        11 -- 运行 boa 服务器
            sudo ./boa
            输入 ps -e 查看是否运行
            注意：
            也可将 boa 添加到系统环境变量
                打开配置文件
                    sudo vi /etc/bash.bashrc
                添加
                    export PATH=$PATH:/home/lzx/share/myboa/boa/boa
                更新配置文件
                    sudo source /etc/bash.bashrc
        12 -- 测试 boa 服务器
        编写 index.html 代码，将其保存在指定的 www 目录下
        <!DOCTYPE html>
        <html>
            <head>
            <title>bj1903</title>
            </head>

            <body> hello world! </body>
        </html>

        在浏览器输入自己 ubuntu 的 ip 地址
        例如：http://10.0.112.241
        查看网页信息显示结果如下:
            hello world!

        注意：这里Windows下能够找到Ubuntu的share是因为在Ubuntu下载了samba服务器。

    2.HTML 语言
        2.1 什么是 HTML?
            1、HTML 是超文本标记语言(Hyper Text Markup Language)
            2、HTML 由各种各样的标签(tag)组成，如<html></html>、<body></body>
            3、HTML 文档 = 网页
            （1）一种纯文本文件，扩展名为.htm 或.html
            （2）最终显示结果取决于 Web 浏览器的显示风格及其对标记的解释能力
            （3）编辑工具：记事本，写字板、Sublime、FrontPage、Dreamweaver 等。

        2.2 HTML 语法
            1、HTML 标签
            （1）由尖括号包围的关键词，比如<html>
            （2）通常是成对（开始标签，结束标签）出现的比如<b></b>,<label></lable>例外：<br><img>
            （3）注释标签：<!-- 注释 -->、<comment>注释</comment>
            2、HTML 元素
            （1）开始标签(start tag)到结束标签(end tag)的所有代码
            3、HTML 属性
            （1）在 HTML 元素的开始标签中规定
            （2）以名称/值对的形式出现:<img src=“1.png">
            开始我的 HTML 之旅
        2.3 HTML 标签

            2.3.1 HTML 头部<head></head>
            主要放置标题标签、元信息标签等

            2.3.2 HTML 主体<body></body>
            放置页面中所有的内容，如文字、标题、链接、图片、表格、表单等

            2.3.3 标题标记<title></title>
                声明网页标题，指示网页作用。
                默认为网页另存为后的网页文件名字
                默认为收藏此网页时的收藏夹中的名字

                例：

                <!DOCTYPE html>	<!-- html版本或者是类型，一般的浏览器都支持 -- >
                <html>
                <head>			<!--html的头部信息：添加一些标题、元信息标签等 -->
                    <title>This is first html</title>		<!-- 标题标签 -->
                </head>
                <body>			<!--html的主题信息 -->
                    nihao beijing,welcome to 1000phone
                </body>
                </html>>

            2.3.3 元信息标记<meta>
                1、提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词
                2、<meta> 标签位于文档的头部，不包含任何内容。
                3、<meta> 标签的属性定义了与文档相关联的名称/值对。
                4、在 HTML 中，<meta> 标签没有结束标签。
                5、<meta> 标签永远位于 head 元素内部。
                6、元数据总是以名称/值的形式被成对传递的。

              * meta元素必须的属性：
                    属性          值              描述
                   content      some_text       定义与http-equiv 或 name属性相关的元信息。
              * meta元素可选的属性：
                   ------------------------------------------------------------
                    属性          值               描述
                   ------------------------------------------------------------
                   http-equiv   content-type    把content属性关联到HTTP头部
                                expires
                                refresh
                                set-cookie
                   ------------------------------------------------------------
                   name         author          把content属性关联到一个名称
                                description
                                keywords
                                generator
                                revised
                                others
                   ------------------------------------------------------------
                   scheme       some_text       定义用于翻译content属性值的格式
                   ------------------------------------------------------------

            用法：
                <meta 属性=值 content=值>
            例如：<meta name="keywords" content=“W3school”>

            例
                <html>
                    <head>
                        <title>02_meta</title>
                        <meta http-equiv="content-type" content="text/html; charset=gb2312" />
                        <meta http-equiv="refresh" content="5;url=http://www.baidu.com/">
                        <meta name="keywords" content="jump">
                    </head>
                    <body>
                        5 秒后我们将去一个神奇的地方！(这个网页的关键字是：jump)
                    </body>
                </html>
            注：content ：内容

            2.3.5 文字标签（<b>、<i>、<u>、<big>、<small>……）

                                粗体<b></b>
                        物理类型{斜体<i></i>
                                下划线<u></u>

                文字标签
                                斜体强调<em></em>
                        逻辑类型{粗体强调<strong></strong>
                                代码<code></code>
                                大小号字体<small></small><big></big>
                                上下标签<sup></sup><sub></sub>

                例子（03_char）:
                <html>
                    <head>
                    <title>03_char</title>
                    </head>
                <body>
                    b:<b>这些文字是粗体的</b>
                    <br>
                    <br>
                    i:<i>这些文字是斜体的</i>
                    <br>
                    <br>
                    u:<u>这些文字带有下划线</u>
                    <br>
                    <br>
                    em:<em>用于强调的文本，一般显示为斜体字</em>
                    <br>
                    <br>
                    strong:<strong>用于特别强调的文本，显示为粗体字</strong>
                    <br>
                    <br>
                    code:<code>用来指出这是一组代码:int main(void)</code>
                    <br>
                    <br>
                    small:<small>规定文本以小号字显示</small>
                    <br>
                    <br>
                    big:<big>规定文本以大号字显示</big>
                    <br>
                    <br>
                    sup:12<sup>2</sup>=144
                    <br>
                    <br>
                    sub:硫酸亚铁的分子式是 Fe<sub>2</sub>SO<sub>4</sub>
                    <br>
                    <br>
                </body>
                </html>
            2.3.6 标题标签：（<h1>-<h6>）
            例:04_head_style.html
                <html>
                    <head>
                        <title>04_head_style</title>
                    </head>
                    <body style="background-color:#90EE90">
                        <br>
                        <h1 style="color:red" >一级标题</h1>
                        <h2 style="color:orange">二级标题</h2>
                        <h3 style="color:yellow">三级标题</h3>
                        <h4 style="color:green">四级标题</h4>
                        <h5 style="color:black">五级标题</h5>
                        <h6 style="color:blue">六级标题</h6>
                        <p style="background-color: white; font-family: arial; color: #ff00ff; font-size:50px;
            text-align: center">普通段落</p>
                        <br>
                    </body>
                </html>


            2.3.7 HTML 样式
            HTML 的 style 属性提供了一种改变所有 HTML 元素的样式的通用方法。

            可以通过 style 来设置背景颜色、字体、字体颜色、字体尺寸、对齐方式。
            格式：
            <TAG style="background-color: white; font-family: arial; color: #ff00ff; font-size:50px; text-align:
        center"></TAG>
            说明：
            HTML 不推荐使用<center>、<font>、<align>、<color>、<bgcolor>等来设置 HTML 样式，style、CSS 成
            为首选

            2.3.8 超链接标签
            超链接<a></a>
                （1）电子邮件超链接
                        <a href="mailto:kitty_zjy@126.com?subject=Hi"></a>
                    注：subject ---主题
                （2）页面内的超链接
                    回到顶部：<a href="#top"></a>
                    回到某一位置：<a name="tome"></a>
                        <a href="#tome"></a>
            （3）页面外的超链接
                    外网：<a href="http://www.baidu.com/"></a>
                    内网：<a href="a.html" target="_blank"></a>
            （4）图片超链接
                    <a src="a.html"><img src="image/a.jpg"></a>
            例子(05_a_href）：

            <html>
                <head>
                    <title>05_a_href</title>
                </head>
                <body>
                    <br>
                    <a href="mailto:kitty_zjy@126.com?subject=Hi">email to others</a>
                    <br>
                    <br>
                    <a href="#mike">去中间看看</a>
                    <br>
                    <br>
                    <a href="http://http://www.1000phone.com//">千锋，用良心做教育</a>
                    <br>
                    <br>
                    <a href="a.html" target="_blank">打开本地一个新的网页</a>
                    <br>
                    <br>
                    <a href="a.html"><img src="image/a.jpg"></a>
                    <br>
                    <br>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p><a name="mike">中间</a></p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <p>some information</p>
                    <a href="#top">回到顶部</a>
                    <br>
                </body>
            </html>
        注：
        <a href="a.html" target="_blank">打开本地一个新的网页</a>
        _blank
            浏览器总在一个新打开、未命名的窗口中载入目标文档

        2.3.9 表格标签<table></table>

                    表格标记
            标签                      描述
            <table>...</table>      用于定义一个表格开始和结束
            <caption>...</caption>  定义表格的标题。在表格中也可以不用此标签
            <th>...</th>            定义表格头单元格。表格中的文字将以粗体显示，在表格中也可以不用此标签，<th>标签必须放在<tr>标签内
            <tr>...</tr>            定义一行标签，一组行标签内可以建立多组由<td>或<th>标签所定义的单元格
            <td>...</td>            定义单元格标签，一组<td>标签将将建立一个单元格，<td>标签必须放在<tr>标签内

            例：06_table_web_resume.html
            代码：
            <html>
                <head>
                    <title>06_table</title>
                </head>
                <body>
                    <table border=10>
                        <caption>table
                        </caption>
                        <tr align=center>
                            <th colspan=3>学生信息
                            </th>
                            <th colspan=2>成绩
                            </th>
                        </tr>
                        <tr align=center>
                            <th>姓名
                            </th>
                            <th>性别
                            </th>
                            <th>专业
                            </th>
                            <th>课程
                            </th>
                            <th>分数
                            </th>
                        </tr>
                        <tr align=center>
                            <td>kitty
                            </td>
                            <td>女
                            </td>
                            <td>电子信息
                            </td>
                            <td>web 应用开发
                            </td>
                            <td>80
                            </td>
                        </tr>
                    </table>
                </body>
            </html>

        2.3.10 表单<form></form>

      * HTML 页面与服务器交互的手段
            (1) 属性
                name：表单的名称
                method：表单数据从浏览器传输到服务器的方法
                    get：将表单数据附加在 URL 地址后面，长度不超过 8192 个字符,不具有保密性，默认为 get
                    post：将表单数据包含在表单的主体中，一起传输到服务器上。没有长度限制,密文传输
                action：用来定义表单处理程序

            (2) <form></form>内的标签
                a、<input> 表单输入标签
                    常用的文本域、按钮都是使用这个标签
                    属性：
                        name    域名称
                        type    域类型
                        value   元素值
                    type 属性值:
                        text    文字域    password    密码域
                        file    文件域    checkbox    复选框
                        radio   单选框    button      普通按钮
                        submit  提交按钮   reset      重置按钮
                        hidden  隐藏域     image      图像域

                b、选择列表 <select><option></option></select>
                    菜单和列表是为了节省网页的空间而产生的
                    属性
                        name        菜单和列表的名称
                        size        显示的选项数目
                        multiple    列表中的选项为多项
                        selected    默认被选中的选项(option 中的属性)

                c、文本域 <textarea></textarea>
                    用来制作多行文本输入域
                    属性
                        name    文字域的名称
                        rows    文字域的行数
                        cols    文字域的列数
                例:07_form.html:
                    <html>
                        <head>
                            <title>07_form</title>
                        </head>
                        <body>
                            <label>=============表单：&ltform&gt=============</label>
                            <form name="form1" method="get" action="/cgi-bin/a.cgi">
                                <br>
                                用户名:<input type="text" name="user">
                                <br>
                                <br>
                                密码 :<input type="password" name="pwd">
                                <br>
                                <br>
                                文件 :<input type="file" name="file">
                                <br>
                                <br>
                                性别：
                                <br>
                                男 :<input type="radio" name="sex" value="female"> 女 :<input type="radio"
                    name="sex" value="male">
                                <br>
                                <br>
                                我喜欢自行车：
                                <input type="checkbox" name="bike">
                                <br>
                                我喜欢汽车：
                                <input type="checkbox" name="vehicle">
                                <br>
                                <br>
                                <select name="cars">
                                    <option value="volvo">Volvo</option>
                                    <option value="BMW" selected>BMW</option>
                                    <option value="Infiniti">Infiniti</option>
                                    <option value="Audi">Audi</option>
                                </select>
                                <br>
                                <br>
                                说点什么吧？
                                <textarea name="comment" rows="3" cols="10"></textarea>
                                <br>
                                <br>
                                <input type="button" value="普通按钮">
                                <br>
                                <br>
                                <input type="hidden" name="fortest" value="testinfo">
                                <br>
                                <br>
                                <input type="image" src="./image/globe_yellow.png">
                                <br>
                                <br>
                                <input type="submit" value="提交">
                                <input type="reset" value="复位">
                            </form>
                        </body>
                    </html>


第三章：Javascript
    3.1 什么是 Javascript?
        Javascript 是一种基于对象并具有安全性能的脚本语言，是由浏览器内解释器翻译成可执行格式后执行，在概
    念和设计方面，Java 和 Jvascript 是两种完全不同的语言。
        Javascript 的四个特点：基于对象的语言、简单性、动态性、跨平台性

    3.2 网页使用 js 脚本的三种方式
        3.2.1 直接添加脚本
            <input type=”button” onclick=”alert(‘欢迎’);” value=”点击”>
            例子(12_js_method1)：
                <html>
                    <head>
                        <title>12_js_method1</title>
                    </head>
                    <body>
                        <input type="button" value="click me" onclick="alert('hello, everyone! My name isJS');">
                    </body>
                </html>

        3.2.2 使用 script 标记插入脚本
            <script type=“text/javascript”>
                //在这里编写 JavaScript 代码
            </script>

        例子(12_js_method2)：
            <html>
                <head>
                    <title>12_js_method2</title>
                </head>
                <body>
                    <script type="text/javascript">
                        alert("oh! see you again!");
                    </script>
                </body>
            </html>

        3.2.3 链接脚本文件
            <script type=“text/javascript”
                src=“文件名.js”> </script>
        例子(12_js_method3)：
        <html>
            <head>
                <title>12_js_method3</title>
            </head>
            <script type="text/javascript" src="12_js_method3.js"></script>
            <body>
            </body>
        </html>

        12_js_method3.js
            alert("oh, see you the third time!");

            alert("Bye Bye!!");

    3.3 js 编程
        3.3.1 js 编程概述

        1、JS 支持的两种类型的注释
        （1）行注释——在行末
            （//注释）
        （2）块注释——可以跨越多行
            （/ *注释* /）
        2、分号是语句的结束符号
        3、大小写
            （1）JavaScript 是大小写敏感的，这意味着大写字母同相应的小写字母是不同的。
            （2）JavaScript 的保留关键字是小写的

        3.3.2 js保留关键字（全部用小写）
            见WPS
        3.3.3 js 变量
        （1）变量的声明
            使用 var 关键字进行变量的声明：var x;
            在声明的时候可以同时对变量进行初始化：var y=4;
            使用逗号将多个变量隔开：var x,y=5,z='hello';
        （2）变量的命名
            变量必须由字母、数字和下划线组成
            字母或者是下划线开头，不可以是数字
            变量不可以是保留字
        （3）变量区别大小写
        3.3.5 js 数据类型
            （1）字符串、数字、布尔、数组、对象、Nul、Undefined
            （2）拥有动态类型
                相同的变量可用作不同的类型

                typeof（x）可以得到变量的类型

            4、运算符
            （1）算数运算符
                +、－、*、/、%、++、－－
            （2）逻辑运算符
                &&、||、!
            （3）比较运算符
                ==、>、<、>＝、<＝、!=、===
            （4）位运算符
                ~、&、|、^、<<、>>、>>>(无符号右移)
            （5）字符串运算符
                +(合并运算符)
            （6）赋值运算符
                =、+=、-=、 *=、/=、%=
            （7）条件运算符
                ? :（条件 ？结果 1 ：结果 2）

        3.3.6 js 控制语句
            1、if 语句
                if(条件表达式){
                    执行语句或语句群;
                }else{
                    执行语句或语句群;
                }
            2、switch 语句
                switch (表达式){
                    case 值 1 :执行语句 1; break;
                    case 值 2 :执行语句 2; break;
                    case 值 n :执行语句 n; break;
                }
            3、for 语句
                for(初始值；判断条件；调整值){执行语句或语句群;}
            4、while 语句
                while(条件表达式){执行语句;}
            5、do while 语句
                do{
                    执行语句;
                }while(条件表达式);

        3.3.7 js 函数
            函数的语法结构:
                function 函数名(参数 1,参数 2,…){
                函数体
            }
            函数参数不是函数的必选内容
            在调用一个需要参数的函数时没有传递参数，JavaScript 就会将参数表示为未定义(undefined)

        3.3.8 js 对象
            JS 是面向对象的编程语言（OOP）
            对象是一种特殊的数据类型，拥有属性和方法，其中属性是指与对象有关的值;方法是指对象可以执行的行为。
            其中 JavaScript 中的常用对象：浏览器对象 Window、文本对象 Document（HTML DOM）、
            内部对象 Date、 Math、 String。

            3.3.8.1 浏览器对象（window 对象）
                Window 对象表示浏览器中打开的窗口，打开一个 HTML 网页会创建一个 window 对象
                Window 对象是全局对象
                window.open()打开一个新的窗口
                window.close()关闭当前窗口
                window.location.href：返回完整的 URL;对其进行赋值，则能够跳转到相应的网页

                    例:14_js_window.html
                        <html>
                            <head>
                                <title>14_js_window</title>
                            </head>

                            <script type="text/javascript" src="14_js_window.js"></script>

                            <body>
                                <br>
                                <br>
                                <input type="button" value="1.显示 URL 地址" onclick="window_show_href()">
                                <br>
                                <br>
                                <input type="button" value="2. 修 改 href, 实 现 当 前 网 页 跳 转 " onclick="window_set_href()">
                                <br>
                                <br>
                                <input type="button" value=" 通 过 open 方 法 ， 打 开 一 个 新 的 网 页 窗 口 " onclick="window_open()">
                                <br>
                                <br>
                                <input type="button" value=" 通 过 close 方 法 ， 关 闭 当 前 窗 口 " onclick="window_close()">
                            </body>
                        </html>


                14_js_window.js：

                function window_show_href()
                {
                    alert(window.location.href);//显示当前 URL
                }
                function window_set_href()
                {
                    window.location.href = "http://www.hao123.com/"; //修改 href，实现网页跳转
                }
                function window_open()
                {
                    window.open("http://www.baidu.com");//打开一个新的窗口
                }
                function window_close()
                {
                    window.close();//关闭当前窗口
                }

            3.3.8.2 文本对象（Document 对象）

                每个载入浏览器的 HTML 文档都会成为 Document 对象。
                Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问

                1、提供了从 JS 脚本中对 HTML 页面中的所有元素进行访问
                2、可以通过 getElementById()方法,来根据对应的 ID 号去访问、控制 HTML 页面中的标签元素
                3、可以通过 title，URL 属性获取当前文档的标题，URL 信息等
                4、可以通过 write 方法在 HTML 页面中写入 HTML 表达式
            例:15_js_document.html
                <html>
                    <head>
                    <title>15_js_document</title>
                    </head>
                    <script type="text/javascript" src="15_js_document.js"></script>
                    <body>
                    <label id="label2">label_text</label>
                    <input type="button" value="change_label" onclick="change_label()">
                    <br>
                    <br>

                    <input id ="input2" type="text" value="input_text">
                    <input type="button" value="change_input" onclick="change_input()">
                    <br>
                    <br>

                    <img id="img2" src="./img/document.png" width=200 height=200 >
                    <input type="button" value="change_src" onclick="change_img()">
                    </body>
                </html>

            15_js_document.js
                alert("title:"+document.title);
                alert("URL:"+document.URL);
                document.write("<h1>Hello World!</h1>");

                function change_label()
                {
                    document.getElementById("label2").innerHTML="name";
                }

                function change_input()
                {
                    document.getElementById("input2").value="kitty";
                }
                function change_img()
                {
                    document.getElementById("img2").src="./img/change.png";
                }
            3.3.8.3 内部对象（Date 对象）
                提供了操作时间和日期的方法
                拥有一系列属性和方法，可以用来获取系统当前时间或者设置 Date 对象中的时间
                通过 getTime()方法可返回距 1970 年 1 月 1 日 00:00:00.000（GMT 时间）到现在的毫秒数。GMT 是格林威治标准时间
                    （1）Date 对象方法
                    getFullYear()：返回当前年份
                    getMonth()：返回当前月份，0～11
                    getDay()：返回星期中的某一天，0~6,0 表示周日
                    getDate()：返回一月中的某一天
                    getHours()：返回当前时间的小时，0～23
                    getMinutes()：返回当前时间的分钟，0～59
                    getSeconds()：返回当前时间的秒，0～59

            setTimeout 与 setInterval 函数区别：

            setTimeout 函数设置超时调用函数，超时后自动调用所设置的函数。超时后自动调用了回调函数，

            如果还想调用回调函数，必须重新调用 setTimeout 进行超时设定。

            而 setInterval 函数只需要设置一次，就可以多次调用回调函数，直到调用 clearInterval

            例:16_js_date.html
                    <html>
                        <head>
                        <title>16_js_date</title>
                        <script type="text/javascript" src="16_js_date.js"></script>
                        </head>
                        <body>
                        <p>
                        This example demonstrates the if..else if...else statement and object Date. </p>
                        </body>
                    </html>

            16_js_date.js

                var d = new Date();
                var hour = d.getHours();
                document.write("<br>");
                document.write("现在的时间是：");
                document.write(d.getFullYear());
                document.write("年");
                document.write(d.getMonth()+1);
                document.write("月");
                document.write(d.getDate());
                document.write("日");
                document.write(" 星期");
                document.write(d.getDay()+" ");
                document.write(d.getHours());
                document.write("点");
                document.write(d.getMinutes());
                document.write("分");
                document.write(d.getSeconds());
                document.write("秒");
                document.write("<br>");
                document.write("<br>");
                if (hour < 12)
                {
                    document.write("Good morning");
                }
                else if (hour < 18)
                {
                    document.write("Good afternoon");
                }
                else if(hour < 24)
                {
                    document.write("Good night");
                }

        例: 17_js_setTimeout.html
                <html>
                <head>
                    <title>_time_by_setTimeout</title>
                </head>

                <script type="text/javascript" src="time_by_setTimeout.js"></script>

                <body onload="start_onload()">

                <div align="center">

                    <h1>Qfedu Timer</h1>
                    <input type="text" id="time">
                    <br>
                    <input type="button" value="时间暂停" onclick="stop()">
                    <input type="button" value="时间开始" onclick="start()">

                </div>
                </body>
                </html>


        time_by_setTimeout.js：

            var stop_flag = 0;

            function timeout()
            {
                var time = new Date();
                var h = time.getHours();
                var m = time.getMinutes();
                var s = time.getSeconds();

                document.getElementById("time").value = h+":"+m+":"+s;

                stop_flag = setTimeout("timeout()",1000); //指定的毫秒数后调用函数 timeout
            }
            function start_onload()
            {
                timeout();
            }
            function stop()
            {
                clearTimeout(stop_flag); //通过 setTimeout 返回值，停止定时
            }
            function start()
            {
                timeout();
            }

        例子（17_js_setInterval）：
            <html>
            <head>
                <title>_time_by_setInterval</title>
            </head>

            <script type="text/javascript" src="time_by_setInterval.js"></script>

            <body onload="start_onload()">
            <div align="center">

                <h1>Qfedu Timer</h1>
                <input type="text" id="time">
                <br>
                <input type="button" value="时间暂停" onclick="stop_1()">

            </div>
            </body>

            </html>

        time_by_setInterval.js
            var stop_flag = 0;
            function time()
            {
                var time = new Date();
                var h = time.getHours();
                var m = time.getMinutes();
                var s = time.getSeconds();
                document.getElementById("time").value = h+":"+m+":"+s;
            }

            function start_onload()
            {
                stop_flag = setInterval("time()",1000);//在指定的毫秒数后调用函数 time()函数
            }
            function stop_1()
            {
                clearInterval(stop_flag); //通过 setInterval()返回值，停止调用
            }

        3.3.8.4 内部对象（Math 对象）
            执行常见的算数任务
            使用 Math 的属性和方法的语法：
            var pi_value=Math.PI; var sqrt_value=Math.sqrt(15);
        例：js_math.html
            <html>
                <head>
                    <title>19_js_string</title>
                </head>
                <script type="text/javascript" src="js_math.js"></script>

                <body>
                数字 1：<input type="text" id="num1" size=50>
                <br>
                <br>
                数字 2：<input type="text" id="num2" size=50>
                <br>
                <br>
                结果：<input type="text" id="result" size=50>
                <br>
                <br>

                <input type="button" value="求两个数的较大值" onclick="fun(1)">
                <input type="button" value="求两个数的和" onclick="fun(2)">
                <br>

                <br>
                <br>
            </body>
        </html>


    js_math.js：

            function fun(deal_num)
            {
                var num1 = document.getElementById("num1").value;//
                var num2 = document.getElementById("num2").value;
                if(isNaN(num1) || isNaN(num2))
                {
                    alert("请输入有效的数字！");
                    document.getElementById("num1").value='';
                    document.getElementById("num2").value='';
                    document.getElementById("result").value='';
                    return ;
                }
                var dest;//存储处理结果
                switch(deal_num)
                {
                case 1:
                    alert("求较大值！！！");
                    alert(Number(num1));
                    alert(Number(num2));
                    dest =Math.max(Number(num1),Number(num2));
                    break;
                case 2:
                    dest =Number(num1)+Number(num2);
                    break;
                }
                document.getElementById("result").value = dest;//显示结果
            }

        3.3.8.5 内部对象（String 类 对象）

        String 对象用于处理文本（字符串）
            字符串是 JavaScript 的一种基本的数据类型。
            String 对象定义了大量操作字符串的方法，例如从字符串中提取字符或子串，或者检索字符等
            常用方法
            charAt()返回在指定位置的字符
            indexOf()检索字符串
            substr()从起始索引号提取字符串中指定数目的字符串
            substring()提取字符串中两个指定的索引号之间的字符串

        例: 19_js_string.html
            <html>
                <head>
                    <title>19_js_string</title>
                </head>
                <script type="text/javascript" src="19_js_string.js"></script>

                <body>
                    原字符串：<input type="text" id="src" size=50>
                    <br>
                    <br>
                    处理方式：<input type="text" id="way" size=50>
                    <br>
                    <br>
                    得到结果：<input type="text" id="dest" size=50>
                    <br>
                    <br>
                    <input type="button" value="1.返回指定位置字符" onclick="deal_string(1)">
                    <input type="button" value="2.检索字符串" onclick="deal_string(2)">
                    <br>
                    <input type="button" value="3. 从 起 始 索 引 号 提 取 字 符 串 中 指 定 数 目 的 字 符 " onclick="deal_string(3)">
                    <br>
                    <input type="button" value="4. 提 取 字 符 串 中 介 于 两 个 指 定 下 标 之 间 的 字 符 " onclick="deal_string(4)">
                    <br>
                    <br>
                    <br>
                    假设原字符串为：hello world
                    <br>
                    1.处理方式输入：0
                    <br>
                    按下《1.返回指定位置字符》则查找第二个字符，得到结果为：h
                    <br>
                    <br>
                    2.处理方式输入：w
                    <br>
                    按下《2.检索字符串》则查找 w 在字符“hello world”中的位置，得到结果为：6
                    <br>
                    <br>
                    3.处理方式输入：1,3
                    <br>
                    按下《3.从起始索引号提取字符串中指定数目的字符》获取从下标 1 开始后的 3 个字
                    符，得到结果为：ell
                    <br>
                    <br>
                    4.处理方式输入：2,4
                    <br>
                    按下《4.提取字符串中介于两个指定下标之间的字符》获取下标从 2 到 4 之间的
                    （4-2=2）个字符，得到结果为：ll
                </body>
            </html>

    19_js_string.js:
            function deal_string(deal_num)
            {
                var src = document.getElementById("src").value;//
                var way = document.getElementById("way").value;
                var dest;//存储处理结果
                switch(deal_num)
                {
                    case 1:
                        dest = src.charAt(Number(way));//返回在指定位置的字符。
                        break;
                    case 2:
                        dest = src.indexOf(way);//lastIndexOf();从后向前搜索字符串。
                        break;
                    case 3:
                        / ****src.substr(start,length)**** /
                        var start = way.substr(0,1);
                        var length = way.substr(2,1);
                        dest = src.substr(Number(start),Number(length));//字符串中抽取从第一个参数下
                        标开始的指定数目（第二个参数）的字符。
                        break;
                    case 4:
                        / ****src.substring(start,stop)*** /
                        var start = way.substring(0,1);
                        var stop = way.substring(2);
                        dest = src.substring(Number(start),Number(stop));//提取字符串中介于两个指定
                        下标之间的字符。
                        //dest = src.substring(2);//提取字符串从 2 开始以后的字符
                        break;
                }
                document.getElementById("dest").value = dest;//显示结果
            }


        3.3.8.6 其他对象
            例子（js_print）：
                <html>
                    <head>
                        <title>JS 打印机
                        </title>
                        <script type="text/javascript" src="js_printer.js">
                        </script>
                    </head>
                    <body onload="start_printer()">
                        <div id="content" style="text-align:center;font-size:20px;">
                        </div>
                    </body>
                </html>

    3.3.9 全局函数
        全局函数可用于整个 JavaScript 程序中
            见WPS表
        例子（18_js_function）：
            <html>
                <head>
                    <title>18_js_function</title>
                </head>
                <script type="text/javascript" src="18_js_function.js"></script>
                <body>
                    data1:<input type="text" id="data1"/>
                    <br>
                    data2:<input type="text" id="data2"/>
                    <br>
                    <br>
                    result:<label id="result"></label>
                    <br>
                    <br>
                    <input type="button" id="add" value="相加" onclick="calc(0)"/>
                    <input type="button" id="minus" value="相减" onclick="calc(1)"/>
                </body>
            </html>

        18_js_function.js：
            function calc(action)
            {
                if(isNaN(document.getElementById("data1").value) || isNaN(document.getElementById("data2").value))
                {
                    alert("请输入有效的数字！");
                    document.getElementById("data1").value='';
                    document.getElementById("data2").value='';
                }
                else
                {
                    if(0 == action)
                    document.getElementById("result").innerHTML=Number(document.getElementById("data1"). value)+Number(document.getElementById("data2").value);
                    else if(1 == action)
                    document.getElementById("result").innerHTML=Number(document.getElementById("data1"). value)-Number(document.getElementById("data2").value);
                }
            }

    第三章：AJAX
        3.1 AJAX 概述
        概述：
            1、AJAX 是 Asynchronous（异步的） JavaScript And XML 的缩写
            2、AJAX 是一种用于创建快速动态网页的技术
            3、AJAX 不是新的编程语言，而是一种使用现有标准的新方法
            4、AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。
            传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面
            5、AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。
            6、有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。
        AJAX 是基于现有的 Internet 标准
            AJAX 是基于现有的 Internet 标准，并且联合使用它们：
                1、XMLHttpRequest 对象 (异步的与服务器交换数据)
                2、JavaScript/DOM (信息显示/交互)
                3、CSS (给数据定义样式)
                4、XML (作为转换数据的格式)

            浏览器是借助 JS 与服务器通信的，js 可以从浏览器获取数据，也可以更新浏览器的数据。
            浏览器与服务器通信采用的就是 AJAX 技术，AJAX 核心是 XMLHttpRequest 对象;
            也就是说，咱们学习 AJAX 掌握 XMLHttpRequest 对象是非常重要的。这个对象有很多种方法可以实现浏览器与服务器之间的传递信息。

            通过 JavaScript 的 XMLHttpRequest 对象完成发送请求到服务器并返回结果的任务，然后使用 JavaScript 更新局部的网页;
                具有异步特性;
                   什么是异步特性呢，消息的出现是随机的，通信双方不需要建立同步时钟


        3.2 AJAX 原理

            AJAX 局部更新网页流程图 ：

            异步流程：
                1、创建对象
                2、设置回调函数 ，fun 函数
                3、open 创建服务器请求
                4、send 向服务器发送请求，
                5、服务器有结果会自动调用 fun 回调函数
                    在回调函数里面根据服务器返回的响应信息 更新用户界面


        3.3 XMLHttpRequest
            3.3.1 根据不同的浏览器创建异步请求对象

            1、创建一个 xmlRequest
                function getXMLHttpRequest()
                {
                    var xmlhttp = null;
                    if (window.XMLHttpRequest)//自动检测当前浏览器的版本，如果是 IE5.0 以上的高版本的浏览器
                    {
                        // code for IE7+, Firefox, Chrome, Opera, Safari
                        xmlhttp=new XMLHttpRequest();//创建请求对象
                    }
                    else////如果浏览器是底版本的
                    {
                        // code for IE6, IE5
                        xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");//创建请求对象
                    }
                    return xmlhttp;//返回请求对象
                }
            在 js 文件中开始定义这个函数，其他 js 函数直接调用就能创建一个异步请求对象

            3.3.2 标准的 XMLHttpRequest 属性
                Onreadystatechange 每个状态改变时都会触发这个事件处理器，通常会调用一个 JavaScript 函数。

                状态：

                readyState：请求的状态。0 = 未初始化，1 = 正在加载，2 = 已加载，3 = 交互中，4 = 完成

                status：服务器的 HTTP 状态码（200 对应 OK，404 对应 Not Found（未找到））

                状态的改变会触发异步函数，调用回调函数。

                不是每一种状态改变都要处理，一般在 readyState 状态值为 4，status 状态值为 200 的时候，处理服务器应答，所
                以在回调函数里写一个判断，判断 readyState 为 4，status 为 200，再做处理。

                responseText 和 responseXML 就是服务器的反馈的结果。

            3.3.3 标准的 XMLHttpRequest 方法
                异步流程：
                    1、创建对象
                    2、设置回调函数 ，fun 函数
                    3、open 创建服务器请求
                    4、Send 向服务器发送请求，
                    服务器有结果会自动调用 fun 回调函数
                同步流程：
                    1、创建对象
                    2、open 建立对服务器的请求
                    3、send 向服务器发送请求
                    4、fun 函数处理，服务器反馈结果。


    第四章：CGI 编程
（服务器与硬件之间沟通的桥梁。它能够编译运行c程序。因此，可以通过浏览器控制硬件端）
    4.1 什么是 CGI?
        CGI 是通用网关接口(Common Gateway Interface);是 HTTP 服务器与其它程序进行“交谈”的工具
        通过 CGI 接口就能在服务器端运行其他的程序
    4.2 CGI 处理步骤（整个流程还是在AJAX中编写的）
        1、通过浏览器将用户请求送到服务器               可以通过AJAX
        2、服务器接收用户请求并交给 CGI 程序处理         CGI程序就相当于C程序
        3、CGI 程序把处理结果传送给服务器
        4、服务器把结果送回到浏览器

    4.3 CGI 编程
        1、CGI 可以用任何一种语言编写，只要这种语言具有标准输入、标准输出、和获取环境变量
            （1）CGI 程序通过标准输入(stdin)、标准输出(stdout)实现与 web 服务器间信息的传递
            （2）环境变量为 Web 服务器和 CGI 接口之间约定的,用来向 CGI 程序传递一些重要的参数
        2、CGI 传送给 Web 服务器的信息可以用各种格式,通常是以 HTML 文本或者 XML 文本的形式
            （1）传输 HTML 文本第一行输出的内容必须是”Content-Type:text/html”
            （2）传输 XML 文本第一行输出的内容必须是”Content-Type:text/xml”
            （3）还有其他的一些格式：JIF(image/gif)、JPEG(image/jpeg)、AVI(video/avi)

            例子：
            #include <stdio.h>

            int main(void)
            {
                printf("content-type:text/html\n\n");
                printf("<html>\n<TITLE>CGI1:CGI hello!</TITLE>\n");
                printf("<center><H1>hello, this is frist CGI demo!</H1></center>\n</html>");
                return 0;
            }
        3、两个重要的 CGI 环境变量
            （1）QUERY_STRING：在浏览器端以 GET 的方法输入的数据，数据的内容就是 url 问号后的内容

        例子：
            #include <stdio.h>
            #include <stdlib.h>

            int main(void)
            {
                char *data = NULL;
                float a = 0.0, b = 0.0;
                char c = 0;
                printf("content-type:text/html\n\n");
                data = getenv("QUERY_STRING");
                if(NULL == data)
                {
                    printf("error");
                    return 0;
                }
                //printf("data is:%s\n", data);
                sscanf(data, "%f%c%f",&a, &c, &b);
                if('+' == c)
                {
                    printf("%f", a+b);
                }
                else if('-' == c)
                {
                    printf("%f", a-b);
                }
                else
                {
                    printf("error");
                }
                return 0;
            }

        （2）CONTENT_LENGTH：在浏览器端以 POST 方法输入的数据的字节数，数据的内容通过标准输入获取。
            例子：
            #include <stdio.h>
            #include <stdlib.h>

            int main(void)
            {
                char *dataLen = NULL,buff[100] = {0};
                float a = 0.0, b = 0.0;
                char c = 0;
                int len = 0;

                printf("content-type:text/html\n\n");
                dataLen = getenv("CONTENT_LENGTH");
                if(NULL == dataLen)
                {
                    printf("error1");
                    return 0;
                }
                else
                {
                    len = atoi(dataLen);
                    if(len > 0)
                    {
                        if(NULL == fgets(buff, len+1, stdin))
                        {
                        printf("error2");
                        return 0;
                        }
                        else
                        {
                            sscanf(buff, "%f%c%f",&a, &c, &b);
                            if('+' == c)
                            {
                            printf("%f", a+b);
                            }
                            else if('-' == c)
                            {
                            printf("%f", a-b);
                            }
                            else
                            {
                            printf("error3");
                            }
                        }
                    }
                }
                return 0;
            }


        （3）常用的 CGI 环境变量
            见WPS


*/







//程序区
//########################################################################
//代码区

#include <iostream>

using namespace std;

int main()
{
    cout << "Hello World!" << endl;
    return 0;
}
